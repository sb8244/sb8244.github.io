<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen Bussey's Software Engineering Blog</title>
  <id>https://stephenbussey.com</id>
  <link href="https://stephenbussey.com"/>
  <link href="https://stephenbussey.com/feed.xml" rel="self"/>
  <updated>2018-02-04T19:57:00-05:00</updated>
  <author>
    <name>Stephen Bussey</name>
  </author>
  <entry>
    <title>28 Days - Sourcing Libraries from Private Github</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html"/>
    <id>https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html</id>
    <published>2018-02-04T19:57:00-05:00</published>
    <updated>2018-02-04T20:29:42-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Hex is currently working on &lt;a href="https://hex.pm/docs/private" target="_blank"&gt;private organizations&lt;/a&gt; which
are in beta. Until the full details of those are public and available, you may find
yourself needing to source Elixir libraries privately. You may also just desire a quick
fix and not setting up private packages. Enter git sourced packages.&lt;/p&gt;

&lt;h2&gt;Mix and Git&lt;/h2&gt;

&lt;p&gt;At the simplest form, you can think of git sourced dependencies as a clone of the provided
repo using system git. In fact, the implementation is
a &lt;a href="https://github.com/elixir-lang/elixir/blob/f77cc2657cf981fdf819915f1ee15e69c3cd91ad/lib/mix/lib/mix/scm/git.ex#L250" target="_blank"&gt;shell out to git&lt;/a&gt;.
This means any repo which a system can access will be accessible via git, including
repos which are locked behind private access.&lt;/p&gt;

&lt;p&gt;I have seen tags work as a good way to mark the versions in the git repo. The form looks
something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: &amp;quot;v1.0.0&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above mix.exs entry will fetch the mix package named &lt;code&gt;:my_dependency_name&lt;/code&gt; from git@github.com:Organization/repo.git,
commit tagged v1.0.0. &lt;a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank"&gt;Github SSH&lt;/a&gt; access
is used due to the repo being &lt;code&gt;git@github.com&lt;/code&gt; format.&lt;/p&gt;

&lt;h2&gt;Trickery with Docker and CI&lt;/h2&gt;

&lt;p&gt;This all works well locally. In fact, just following the standard tutorial will lead to a working
private dependency, locally. Things get a bit trickier when something like Docker or a build
server is used to fetch your dependency. In this situation, the SSH key of each system would need
to be included on Github. Another difficulty is that Docker containers have to have SSH keys added
to them, they don&amp;rsquo;t come with them standard. All of this leads to another possible solution:
accessing Github via API keys.&lt;/p&gt;

&lt;h2&gt;API Key Setup&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/blog/1509-personal-api-tokens" target="_blank"&gt;Github personal access tokens&lt;/a&gt; can be used
to access certain parts of Github, such as repository access. In order to use one with mix,
just switch out the git url from &lt;code&gt;git@github.com:Organization/repo.git&lt;/code&gt; to
&lt;code&gt;https://#{access_token}@github.com/Organization/repo&lt;/code&gt;. With this solution, any access token
which has read access to the repo will serve as the access into Git.&lt;/p&gt;

&lt;p&gt;There does exist a drawback with this solution, the access token would need to be provided to
every user of the application. This is non-desirable as the access token should really be kept
secret, even to the point of being encrypted docker arguments. With a small tweak, it is possible to
achieve the best of both worlds, SSH locally but access tokens for Docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp deps do
  [
    {:phoenix, &amp;quot;~&amp;gt; 1.3.0&amp;quot;},
  ] ++ private_deps(System.get_env(&amp;quot;MIX_GITHUB_ACCESS_TOKEN&amp;quot;))
end

@my_dependency_version &amp;quot;v1.0.0&amp;quot;

defp private_deps(nil) do
  [
    {:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: @my_dependency_version},
  ]
end

defp private_deps(access_token) do
  [
    {:my_dependency_name, git: &amp;quot;https://#{access_token}@github.com/Organization/repo&amp;quot;, tag: @my_dependency_version},
  ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will append the private dependencies into the deps list, but do so with
either SSH or access token access. Dependency versions should always be constant, so
it is pulled into an attribute.&lt;/p&gt;

&lt;p&gt;One caveat with this approach is that each mix invocation must contain the ENV, not
just &lt;code&gt;deps.get&lt;/code&gt;. This is due to the mix.lock being checked when mix runs, and the
correct dependencies are pulled each time through the above code path.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;With the presented approach, there should be little trouble getting private repos
both locally and in CI, without compromise on security of your keys. If the straight access
token route is taken, take extra care regarding the permissions of the account behind
the key.&lt;/p&gt;

&lt;p&gt;Thanks for reading the fourth post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate the posts to get more and more technical as the time goes on!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Bringing Elixir to Others - New Language vs. New Paradigm</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html"/>
    <id>https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html</id>
    <published>2018-02-03T14:46:00-05:00</published>
    <updated>2018-02-03T15:10:05-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;ll be giving a talk next week about taking Elixir into production. While there are
technical challenges to doing so, I must also consider the human-based challenges that will be faced. For
example, most team members will be learning a new language when they are introduced to Elixir.
If they have been doing object-oriented coding, will a functional coding paradigm get them stuck?
Will OTP and the paradigm of a process based application cause confusion?&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t necessarily present answers to some of these questions today, but rather bring up
questions that I&amp;rsquo;ve heard and alternative ways of thinking about the answers.&lt;/p&gt;

&lt;h2&gt;Functional Programming and Elixir Itself&lt;/h2&gt;

&lt;p&gt;Before all of the fun and excitement of making a real Elixir application comes the challenge of
learning the Elixir language. Most people that ask me about learning Elixir focus on what
types of courses they can pay for online to get into the language. While I&amp;rsquo;m sure that some
people are going to benefit from these courses enormously, it&amp;rsquo;s never the first place I&amp;rsquo;d send
someone. Instead, I recommend the &lt;a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank"&gt;Elixir Getting Started Guide&lt;/a&gt;.
This guide is put together by the official Elixir team and covers an introduction to the language itself.&lt;/p&gt;

&lt;p&gt;As other members of the organization dive into the concepts of Elixir, questions will
be raised about what functional programming is, what does immutability mean, and what is &amp;ldquo;all of this&amp;rdquo; in practice?
Even further questioning might ask &amp;ldquo;what makes the functional paradigm good?&amp;rdquo; Other team members will rely
on the Elixir champion to answer these questions, so be prepared for them to pop up once people start learning.
I read something in a reddit comment today that I really liked on this topic: the value of the data
doesn&amp;rsquo;t change in Elixir, but rather the variables point to new pieces of data. I thought that was a
very straight-forward way of looking at the functional programming model that Elixir brings.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I prep anyone that is going through the getting started guide that it will take probably 2-4 times
to really understand Elixir to the point of being comfortable when reading other people&amp;rsquo;s code. Having
a real world project to read and play around with can lower this learning curve.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;OTP&lt;/h2&gt;

&lt;p&gt;OTP is a cornerstone of writing Elixir applications. There&amp;rsquo;s lot of things about the topic already, but
I had an interesting observation the other day about OTP and how it relates to bringing Elixir to the
rest of an organization:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The majority of business applications could be built with all OTP hidden away by libraries, to the point
of developers not needing to know the details of OTP.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While I think that using OTP can help bring about advantages in an application, especially in a distributed
environment, it is not really necessary. For example, a developer could start a new application today and
serve the HTTP layer with Phoenix. They could then spin up a queue system like ExQ in order to process
background jobs. Finally, they can connect websockets for read/write access to the API. All of this can happen
without ever typing &lt;code&gt;GenServer&lt;/code&gt; in code and create an application which satisfies the business.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t necessarily best practice, but I believe that it&amp;rsquo;s okay to sometimes put aside best practice
in order to achieve an initial velocity. Once the team is rolling, the OTP concepts will come out of the
woodwork and start to make sense, hopefully faster than they would in isolation.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Regardless of how you approach bringing Elixir to the people on your team, realize that you must be a
champion for the education and empowerment of the team. Look for interesting ways to answer questions that
people have and remove the roadblocks that pop-up as quick as you can.&lt;/p&gt;

&lt;p&gt;Thanks for reading the third post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Silly Mistakes I Make Again and Again</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html"/>
    <id>https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html</id>
    <published>2018-02-02T01:30:00-05:00</published>
    <updated>2018-02-02T02:10:29-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;It&amp;rsquo;s day 2 of my 28 days of Elixir blogging. I have 5 more ideas in the funnel, and I fear
that coming up with 28 interesting topics will be hard. I&amp;rsquo;ll definitely be leaning on
co-workers for ideas, but don&amp;rsquo;t hesitate to reach out if you have any interesting ideas
that you&amp;rsquo;d want me to explore!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been writing Elixir daily at SalesLoft, and have gotten pretty quick with development
and testing of my apps. However, a few things just keep catching me up every time:&lt;/p&gt;

&lt;h2&gt;Charlist and Strings&lt;/h2&gt;

&lt;p&gt;In both Ruby and Javascript, it is acceptable to swap &amp;lsquo; and &amp;ldquo;  for strings, in many cases.
This means that &amp;#39;a&amp;rsquo; === &amp;quot;a&amp;rdquo; in Javascript. However, &amp;lsquo;a&amp;rsquo; != &amp;ldquo;a&amp;rdquo; in Elixir. This is due to
charlist and string being implemented differently. Charlist is often used for interfacing
with erlang directly, because erlang does not have the concept of &amp;ldquo;strings&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;One mistake I will often catch is swapping the usage of the quote constructs and then
doing equality or other comparisons, and being bewildered when the strings do not match.
Catching this error can be a bit tricky if the error message doesn&amp;rsquo;t show you that the
types are different, but a usual symptom is being completely bewildered why two matching
strings are not matching. The most significant place to pay attention to is when interfacing
with code between libraries, as the target and source are separated.&lt;/p&gt;

&lt;h2&gt;Running mix test on the source file&lt;/h2&gt;

&lt;p&gt;This one is always a face-palmer. When running &lt;code&gt;mix test test/my_test.exs&lt;/code&gt;, be careful of
accidentally copying a path like &lt;code&gt;mix test lib/my.ex&lt;/code&gt;. The symptom of this mistake is a
passing spec suite which runs 0 specs, and complains about a re-defined module.&lt;/p&gt;

&lt;h2&gt;Define a test file with the same name as the real module, rather than test&lt;/h2&gt;

&lt;p&gt;My flow for creating a module is to create the source module (.ex), then running
(opt-g-t) to create a test script (.exs). I will then copy the source module definition
and add ExUnit and &lt;code&gt;Test&lt;/code&gt; to the end of the module.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;m going red/green on my code, I sometimes find myself shocked that a function
doesn&amp;rsquo;t exist when I most certainly just defined it. After looking around wondering
what is going on, I realize I forgot to include &lt;code&gt;Test&lt;/code&gt; at the end of the module. This
re-initializes the module (without real code) but is still a sementically valid
test file.&lt;/p&gt;

&lt;h2&gt;Not recognizing pattern matching in test helpers such as assert received&lt;/h2&gt;

&lt;p&gt;This is one of the more interesting / subtle mistakes that I find myself making. I especially
see this in older Elixir code that I wrote where I didn&amp;rsquo;t fully understand what was
going on.&lt;/p&gt;

&lt;p&gt;I will be doing a task like writing / testing a websocket channel and find that my
code passes perfectly when I know that it&amp;rsquo;s definitely not working correctly. I will
be trying to make my code go red but simply can&amp;rsquo;t make it. Usually, it turns out
that I&amp;rsquo;m using a function like &lt;a href="https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html#assert_push/3" target="_blank"&gt;assert_push/3&lt;/a&gt;
that is actually a macro. The way these are written, the function is actually
doing pattern matching rather than exact checks. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is different than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, ^expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is highlighted in the assert_push documentation, but essentially the first example
doesn&amp;rsquo;t check that the payload is &lt;em&gt;exactly&lt;/em&gt; the expected payload. This means that there could
be something like a data leak and our test wouldn&amp;rsquo;t catch it! Pattern matching the responses
can be super useful, but make sure that it&amp;rsquo;s happening when you expect it, and not
when you don&amp;rsquo;t!&lt;/p&gt;

&lt;p&gt;Thanks for reading, today. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Development Environment</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html"/>
    <id>https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html</id>
    <published>2018-02-01T01:30:00-05:00</published>
    <updated>2018-02-02T01:41:19-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Welcome to day 1 of (hopefully) 28 days of Elixir! I&amp;rsquo;ve set a goal to write a technical blog
post every single day this month, and I&amp;rsquo;m really excited about Elixir right now. I don&amp;rsquo;t know
what the entire series will bring, but I do know that I&amp;rsquo;ll basically have to be putting all of my
thoughts and experiences about Elixir out there over the next month.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to start this series off with something light: development environments. Specifically,
the one that I use and things that I&amp;rsquo;ve found enjoyable coming from another language like Ruby
or Javascript. I don&amp;rsquo;t intend to convince anyone of anything on this (especially with regards
to editors), but I do think there&amp;rsquo;s some interesting things about Elixir specifically that
can apply to every environment. Let&amp;rsquo;s jump in.&lt;/p&gt;

&lt;h2&gt;Elixir Installation&lt;/h2&gt;

&lt;p&gt;I use &lt;a href="https://github.com/taylor/kiex" target="_blank"&gt;kiex&lt;/a&gt; to manage my elixir versions
and &lt;a href="https://github.com/kerl/kerl" target="_blank"&gt;kerl&lt;/a&gt; to manage my erlang/OTP versions. kiex has
been great, it&amp;rsquo;s really easy to use! I have to say that I&amp;rsquo;m genuinely impressed with
how little speed bumps I&amp;rsquo;ve encountered over time. I do recommend using some sort of
version manager rather than brew, because there will definitely be more than one project
in Elixir over time!&lt;/p&gt;

&lt;p&gt;kerl on the other hand, has generally been fairly painful to use. I think the biggest
thing here is that Elixir versions need recompiled once OTP is changed. I could be
wrong here because I haven&amp;rsquo;t had to do it too often, but I do distinctly remember
significant pain from the OTP 20 upgrade. This happens very infrequently though.&lt;/p&gt;

&lt;p&gt;One thing that I wish kiex had was the concept of a .elixir-version file like rbenv. It
has to be done manually right now, which is error prone on a team.&lt;/p&gt;

&lt;h2&gt;My Editor&lt;/h2&gt;

&lt;p&gt;Although I&amp;rsquo;ve tried to get into other editors over time, I have found myself drawn again
and again to the simplicity and flexibility of atom, so that&amp;rsquo;s what I&amp;rsquo;ve been using lately.
There are 3 packages that I use specifically for atom that are, I think, absolute
must haves: atom-elixir, language-elixir, elixir-jump-around.&lt;/p&gt;

&lt;p&gt;atom-elixir and language-elixir provide the base for the actual act of authoring code.
The auto-complete functionality works generally well, although there are some core quirks.
Due to how Elixir compilation works, tools like atom-elixir look into the actual _build
output of the code to produce auto-complete and documentation services. This is really interesting
to me, because it means that &lt;em&gt;any&lt;/em&gt; editor should be able to accomplish that same task. Whether
emacs, vim, vscode, whatever is being used, it should be completely achievable to have full
auto-complete and documentation capabilities.&lt;/p&gt;

&lt;p&gt;In addition to great auto-complete capabilities, atom-elixir has a really good &amp;ldquo;go to definition&amp;rdquo;
functionality. When I am authoring Ruby code, I find that only Rubymine has been able to
achieve true definition jumping. ctags can provide some of it, but jumping into installed
libraries is very useful for debugging problems or understanding how a method works. For example,
do you want to know how an Enum method is implemented? Just alt+click and you&amp;rsquo;re there! Elixir&amp;rsquo;s
compilation design makes this all possible in any editor, not just a Jetbrains editor. Check
it out!&lt;/p&gt;

&lt;p&gt;Lastly, &amp;ldquo;jump to test&amp;rdquo; is so useful for me. My typical flow for creating a file has become:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create the module in my lib folder somewhere&lt;/li&gt;
&lt;li&gt;Press opt-g-t to jump to the non-existent file&lt;/li&gt;
&lt;li&gt;Copy the module definition, add Test to it, then save the file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m able to do this entire flow very quickly and without navigating a file tree.&lt;/p&gt;

&lt;h2&gt;Docker vs Native Execution&lt;/h2&gt;

&lt;p&gt;Some people really like to develop software on the OS that is going to run it in production,
and more power to them! However, I&amp;rsquo;ve found myself drawn to having software that is runnable
on my macbook, natively, rather than using a tool like Docker or Vagrant. However, I do utilize
Docker for CI and production build processes.&lt;/p&gt;

&lt;h2&gt;Mix Format&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve begrudgingly accepted the mix formatter over the past few weeks. I find that I often
have issues with getting a file to format in certain situations. This seems like a bug in the formatter,
though. The format itself is generally agreeable but sometimes is not and there is no
customization route. I think that it&amp;rsquo;s better to accept a standard, even if it&amp;rsquo;s not
my desired standard, if it improves the community and team at large.&lt;/p&gt;

&lt;p&gt;I run this manually as I go. Now that I think about it more, I should probably have this setup
in some semi-automated fashion until it becomes too slow.&lt;/p&gt;

&lt;h2&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;That ended up being longer than I anticipated, but I&amp;rsquo;m still sure there are many things
I didn&amp;rsquo;t cover. Feel free to reach out if you have any question about how my setup
works or if you have awesome tools that you can&amp;rsquo;t live without!&lt;/p&gt;

&lt;p&gt;See ya tomorrow hopefully! It is only day 1, so we&amp;rsquo;ll have to see how it goes.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Designing Elixir Supervisor Trees</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html"/>
    <id>https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html</id>
    <published>2018-01-07T21:47:00-05:00</published>
    <updated>2018-02-01T01:56:07-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Over the past year, I&amp;rsquo;ve been getting more and more into Elixir. The language and
paradigm has shifted how I think about coding in Ruby and has been incredibly &lt;em&gt;fun&lt;/em&gt;
to work with. One of the core concepts of an Elixir application is the supervision tree.
Let&amp;rsquo;s dive into some patterns that I typically use, along with some real code.&lt;/p&gt;

&lt;h2&gt;Supervisors and Processes&lt;/h2&gt;

&lt;p&gt;A process in Elixir is an isolated unit of execution. Processes have their own stack,
&amp;ldquo;run queue&amp;rdquo;, and garbage collection. Because of this level of isolation, it helps to think
of them as small programs that can talk to other small programs in an application. Processes
are crucial for storing and accessing dynamic data, as well as for implementing transformations
around data. A process executes all operations in its run queue sequentially, but multiple
run queues can execute concurrently (leading to true concurrency). If you are curious about this
specifically, I find
Hamidreza Soleimani&amp;rsquo;s &lt;a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank"&gt;blog post&lt;/a&gt;
fascinating.&lt;/p&gt;

&lt;p&gt;A supervisor is a process that manages the lifecycles of child processes. This most often
comes through as a fault tolerance mechanism. If a process crashes, the parent supervisor
can choose to restart it, let it stay dead, restart it and all peers, etc. A supervisor
can supervise other supervisors, which leads to a supervision tree.&lt;/p&gt;

&lt;h2&gt;Modeling a Problem&lt;/h2&gt;

&lt;p&gt;The problem that I&amp;rsquo;m going to discuss today is the model of a game server for the game
generals.io. This is a turn-based &amp;ldquo;real-time&amp;rdquo; strategy game that involves capturing towns
with armies and overtaking the enemy generals. Users can queue up moves to execute sequentially
over turns. This allows complex moves to be planned out and executed without losing time.&lt;/p&gt;

&lt;p&gt;In this problem, there are a few concepts that stick out to me:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Board: A board is the representation of what the current state of the game is. This would
include the cell types, the state of the armies, the fog of war, etc&lt;/li&gt;
&lt;li&gt;Command queue: This stores the entire set of commands for the game. It is write-ahead and
knows what commands have been executed and which are in the future (and on which turn)&lt;/li&gt;
&lt;li&gt;Player list: Not as obvious as the others, but we need to know what players are in a game,
and what the mapping is to their login&lt;/li&gt;
&lt;li&gt;Game: The game contains all of the above things and ticks every so often, progressing the
gameplay along&lt;/li&gt;
&lt;li&gt;Game list: Building an online game requires supporting multiple games at once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m going to walk through each of these concepts (in order) and explain the approach I
took in implementing the supervision tree. First, let&amp;rsquo;s see what that supervision tree
might look like.&lt;/p&gt;

&lt;h2&gt;Supervision Tree for Our Game&lt;/h2&gt;

&lt;p&gt;What I&amp;rsquo;m about to present doesn&amp;rsquo;t come immediately (well, maybe with more practice),
and is something that came about through iterations and testing the waters with different
code. This is the final product, which I&amp;rsquo;ll go into more detail on. The [] syntax indicates
what the children are.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Application -&amp;gt; [GamesSupervisor, GameRegistry, WebEndpoint]
GamesSupervisor (1 child type) -&amp;gt; [GameSupervisor (dynamic)]
GameSupervisor (4 child type) -&amp;gt; [BoardServer, CommandQueueServer, TickServer, PlayerServer]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;BoardServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/board_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;When building the game, I started with the board object and naturally progressed into
the BoardServer. I feel that starting on the inner nodes of the supervisor can make
it more obvious what the next steps are, rather than trying to plan out everything
at once.&lt;/p&gt;

&lt;p&gt;Notes on the code:&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve found myself trying to keep servers as simple as possible,
and executing complex logic in plain old modules which don&amp;rsquo;t have any GenServer
capability. When looking at the BoardServer, I&amp;rsquo;m happy to see that there is no
real logic in it, other than turn + 1.&lt;/p&gt;

&lt;p&gt;Defining a simple interface is crucial for communication between GenServers. I&amp;rsquo;ve
found myself getting stuck in between more verbose interfaces in the past and always
regret whatever brought me there.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice that I don&amp;rsquo;t use any of the GenServer helpers to remove boiler plate.
I&amp;rsquo;ve found that keeping it to pure Elixir makes it easier to read in the long run,
and increases my consistency across projects.&lt;/p&gt;

&lt;h2&gt;CommandQueueServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/command_queue_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Following the theme of keeping GenServers simple, this one is even more simple.
When I&amp;rsquo;m dealing with a GenServer that really only touches one thing, like this one
dealing with a Queue implementation, I do like to reach for Agent. Using an Agent
removes the need to build a real GenServer implementation, and increases the
readability significantly.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t find myself reaching for an Agent often, and will pull it out to a regular
GenServer if it gets too complex.&lt;/p&gt;

&lt;h2&gt;PlayerServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/player_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This is another simple Agent implementation that I feel like got a little bit sloppy.
This is due to the use of a Map rather than a custom data structure. To clean up
this code, I would look at extracting the Map behavior into a specific PlayerList
module.&lt;/p&gt;

&lt;h2&gt;TickServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/tick_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I love this TickServer. One of my favorite lines of code in Elixir has been:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Process.send_after(self(), :start_tick, timeout)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is going to send a message from one process to itself, but set for the future.
This allows creation of non-blocking (while the waiting is happening) GenServer implementations
that are implemented entirely using native Elixir concepts.&lt;/p&gt;

&lt;p&gt;Another interesting point here is that the TickServer accepts a &lt;code&gt;ticker_fn&lt;/code&gt; in the server
initialization. We&amp;rsquo;ll see this pop up in our GameServer later. I thought this technique was
really interesting (and was sort of surprised it worked). It works due to the fact that
a fn in Elixir can be passed around like any other variable, and Elixir is stateless which
means that the fn doesn&amp;rsquo;t get any context from where it is defined. Be warned, however, that
executing a fn in the TickServer is going to block the TickServer until that function
completes; it is not going to execute in the server that defined the fn.&lt;/p&gt;

&lt;h2&gt;GameSupervisor &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/game_supervisor.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s a lot going on in this supervisor, so let&amp;rsquo;s take it slow and just look at a few
specific concepts.&lt;/p&gt;

&lt;p&gt;The first thing to point out is the use of Registry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def start_link(opts = %{game_id: id}) do
  Supervisor.start_link(__MODULE__, opts, name: {:via, Registry, {get_registry_name(), id}})
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the Registry allows for a named dynamic lookup / uniqueness of a GenServer. The
supervisor is defined by the id passed in, which would prevent two games from ever sharing
the same id at the same time. As you can imagine, that would be bad. We can take advantage
of the uniqueness as well, because another GenServer that is started with this id will return
the pid in the start_link call. We&amp;rsquo;ll see this through in the GamesSupervisor below.&lt;/p&gt;

&lt;p&gt;Another useful code snippet is for looking up a process by type under a supervisor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp find_child_type(sup_pid, type) do
  Enum.find(Supervisor.which_children(sup_pid), {nil, nil, nil, nil}, fn({mod, _pid, _type, _}) -&amp;gt;
    mod == type
  end) |&amp;gt; elem(1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve begun putting this in a Utils namespace in my new projects, but the gist is simple.
By using the supervisor&amp;rsquo;s pid, we can list out all of its children and find the one
with a given type (or base it on other things). GameSupervisor only has 1 child of
each type, which makes this work well.&lt;/p&gt;

&lt;p&gt;Our trust &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/game_supervisor.ex#L76" target="_blank"&gt;ticker_fn&lt;/a&gt; is
defined in this GameSupervisor. The reason I took this approach is that the knowledge of how to tick
should belong to something separate from what the ticking behavior is. Looking at this now,
I would probably pull this code into another module since it&amp;rsquo;s so long.&lt;/p&gt;

&lt;h2&gt;GamesSupervisor &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/games_supervisor.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve finally made it to the top of the supervision tree with the GamesSupervisor. This
supervisor takes advantage of the GameRegistry to provide game lookups:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def get_game(id, opts \\ []) do
  options = Keyword.merge([name: __MODULE__], opts)
  Supervisor.start_child(options[:name], [%{game_id: id}]) |&amp;gt; case do
    {:error, {:already_started, pid}} -&amp;gt; pid
    {:error, _} -&amp;gt; nil
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the GameSupervisor is identified by the id, which will return when
&lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; is returned from the start_child call. I use
this pattern in nearly every dynamic supervisor that I&amp;rsquo;ve written. I do typically
implement start/get in the same method (starting if it doesn&amp;rsquo;t exist, getting if it does),
but I found that to not work well as creating a new game involves several complex
operations such as board generation.&lt;/p&gt;

&lt;h2&gt;Registry&lt;/h2&gt;

&lt;p&gt;If you use a Registry, you do need to start it as a process in your application. I
generally just include it at the top level of my
&lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/application.ex#L9" target="_blank"&gt;Application module&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;One good sign that your supervision tree has come together well is a very simple
mounting of it onto your final Application. Writing &lt;code&gt;supervisor(Generals.GamesSupervisor, [])&lt;/code&gt;
seems like a very clean interface for interacting with my game supervision tree, and
I feel good about that.&lt;/p&gt;

&lt;p&gt;Another key thing to think of when writing your supervision tree is what can / will
execute concurrently. For instance, let&amp;rsquo;s say that your PlayerList is implemented in
the same GenServer as the Board. If you want to access the PlayerList to see who is
in a game, it would not be able to run concurrently with Board operations. By splitting
them up into separate GenServer implementations, they can execute concurrently (keep in
mind that Elixir automatically distributes across cores).&lt;/p&gt;

&lt;p&gt;I hope this helped or solidified GenServer concepts for you. Please feel free to reach out
with any cool tips or tricks.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Get Your Rails Out Of My Ruby - HTTP &amp; Controllers</title>
    <link rel="alternate" href="https://stephenbussey.com/2017/09/04/get-your-rails-out-of-my-ruby-http.html"/>
    <id>https://stephenbussey.com/2017/09/04/get-your-rails-out-of-my-ruby-http.html</id>
    <published>2017-09-04T14:33:00-04:00</published>
    <updated>2017-09-29T15:19:43-04:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;On Friday September 22 (2017), I&amp;rsquo;ll be presenting a talk at &lt;a href="http://connect.tech/" target="_blank"&gt;connect.tech&lt;/a&gt; conference entitled &amp;ldquo;Get Your
Rails out of My Ruby&amp;rdquo;. This talk is going to be looking at alternatives to writing Ruby code in a Rails application that don&amp;rsquo;t
involve doing everything the &amp;ldquo;Rails way.&amp;rdquo; This post and future posts leading up to the talk will look at certain common areas
where Rails is used; this post will be about controllers and your HTTP interface.&lt;/p&gt;

&lt;h2&gt;Rails Controllers - Benefits &amp;amp; Challenges&lt;/h2&gt;

&lt;p&gt;Rails has done so much for the Ruby community and is arguably the best collection of &amp;ldquo;getting started practices&amp;rdquo; that exists
for web development. Other frameworks are catching up to it, but it has been innovating in its own way to keep pace. Rails handles
creating a web interface gracefully and provides mechanisms to do it securely (versus rolling it all yourself from scratch).
ActionController, specifically, has a few large benefits (not an exhaustive list):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clean interface to write routes and controllers quickly&lt;/li&gt;
&lt;li&gt;ActionController::Parameters for securely handling parameters, beyond a simple Hash&lt;/li&gt;
&lt;li&gt;Easy to use router&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these benefits, I&amp;rsquo;ve seen some challenges from relying on Rails for everything web-interface related:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The default use of controllers leads to web &amp;amp; application code coupled together tightly&lt;/li&gt;
&lt;li&gt;Many ways to achieve objectives, some better and some worse than others. How do you know what&amp;rsquo;s better when getting started?&lt;/li&gt;
&lt;li&gt;Router is flexible and will let you do things you maybe shouldn&amp;rsquo;t be (1 controller with many endpoints)&lt;/li&gt;
&lt;li&gt;Larger learning curve than may be necessary due to generic functionality&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When getting started with a new application or product, these tradeoffs might be entirely acceptable, and I would argue that they
most likely are acceptable for a majority of use cases. However, these tradeoffs begin to appear less worth it as an application,
business, or customer base increases in size. Specifically, the tight coupling of web and application code.&lt;/p&gt;

&lt;h2&gt;Web / Application Coupling&lt;/h2&gt;

&lt;p&gt;Your app is not a web app; your app is more than that. Your application is solving problems for businesses or consumers. Your application
has a problem domain that isn&amp;rsquo;t just &amp;ldquo;the web.&amp;rdquo; When building your application, are you writing and communicating in your business&amp;rsquo;s
context, or in the context of &amp;ldquo;the web?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Conway%27s_law" target="_blank"&gt;Conway&amp;rsquo;s law&lt;/a&gt; says that your application design will reflect the communication structure
of your business. This is due to the needs of individuals in the organization to communicate effectively with each other. Let&amp;rsquo;s look
at an example of how this might play out in application code:&lt;/p&gt;

&lt;p&gt;Your banking software is designed to support operations of the tellers for your bank branches. When customers come into the bank, they
submit &amp;ldquo;withdrawal slips&amp;rdquo; to the tellers, who process these slips and issue &amp;ldquo;money withdrawals&amp;rdquo; back to the customers. Your company has
codified this business process for the software written for the tellers, which is accessed via a web interface on their computers.
When designing the classes for this software, what are the &amp;ldquo;withdrawal slips&amp;rdquo; and &amp;ldquo;money withdrawals&amp;rdquo; called?&lt;/p&gt;

&lt;p&gt;In the &amp;ldquo;Rails way&amp;rdquo; mindset, these might end up being simple &amp;ldquo;Controller Actions&amp;rdquo; which produce &amp;ldquo;Views&amp;rdquo; viewed by the tellers.
The slips contents are passed around the controllers by &amp;ldquo;params&amp;rdquo;. The web application creeps into the code in this way,
naming concepts by Rails concepts rather than business domains. The web / application domains are now coupled with each other.&lt;/p&gt;

&lt;h2&gt;Problems with Coupling&lt;/h2&gt;

&lt;p&gt;Being real, this tight naming coupling isn&amp;rsquo;t going to cripple your app; you may not even notice side effects for a while. However,
slowly things might end up happening:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Engineers become unable to communicate in the organization without mentally translating concepts&lt;/li&gt;
&lt;li&gt;Engineers doing refactors are struggling to discover the business intents, as the business concepts are not obvious&lt;/li&gt;
&lt;li&gt;Tighter coupling has caused bugs in one section to propagate down to another section of code, causing worse problems&lt;/li&gt;
&lt;li&gt;No mapping of language was ever created, people aren&amp;rsquo;t sure of the mapping anymore&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these problems are going to escalate to the business level at some point, they aren&amp;rsquo;t simply engineering issues. Particularly
decreased productivity and large refactors to reduce coupling.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/get-your-rails-out/traditional-design.png" alt="traditional rails coupling, large seam" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;Example of Rails design that introduces a high degree of coupling&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;In the above image, a traditional Rails Way design is shown. Rails routes the request to a controller, which utilizes service objects
to implement business logic. These service objects are tied to the controller if any business logic is implemented in the controller,
such as parameter defaults, safety checks, etc. It is possible to reduce coupling by making the controllers as dumb as possible, but
I&amp;rsquo;m not sure that this plays out as expected in the real world.&lt;/p&gt;

&lt;p&gt;In my view, the biggest issue with this design is that the application logic ends up tied in some way to a controller. This makes it
not possible to invoke the business logic without reading the controller, understanding it, and duplicating that setup somewhere else.
This introduces the above issues, such as lack of clear understanding, tight coupling, and more difficult refactors.&lt;/p&gt;

&lt;h2&gt;A different way?&lt;/h2&gt;

&lt;p&gt;What if our business logic was able to be separated from the web logic via object separation. This is fairly common in the Rails
world with the introduction of &amp;ldquo;service objects.&amp;rdquo; These objects are wrappers to encapsulate behavior. Instead of the &amp;ldquo;withdrawal slip&amp;rdquo;
being represented by the &lt;code&gt;params&lt;/code&gt; of a &lt;code&gt;Request&lt;/code&gt;, perhaps there is a &lt;code&gt;WithdrawalSlip&lt;/code&gt; object which has codified that business concept.
The controller will then create a &lt;code&gt;WithdrawalSlip&lt;/code&gt; and process it via a &lt;code&gt;MoneyWithdrawalProcess&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This small alternative immediately provides some benefits to the engineers and organization. The concepts are apparent in the code,
and the engineering team is able to make sense of the names compared to how the business operates. The changes allows the codebase
to get further, but there are still some problems. Every endpoint for the banking interface now has to create and manage respective
objects, and construct results into responses for the tellers. The interface has become less Rails specific, but actual functionality
is still heavily reliant on Rails. This means that engineers unfamiliar with the codebase (new hires) may end up doing something
The Rails Way rather than the way that has been established by the team, simply because it&amp;rsquo;s possible and they are not familiar with
the team&amp;rsquo;s way yet. This might lead to tension (&amp;ldquo;You only do it this way because you&amp;rsquo;re afraid of change!&amp;rdquo;) or code erosion over time,
neither of which are good.&lt;/p&gt;

&lt;h2&gt;Separating business logic completely away from the web logic&lt;/h2&gt;

&lt;p&gt;What if the web logic was completely separated from the business logic? I don&amp;rsquo;t mean the service object extraction mentioned previously,
but an actual fully operating application that doesn&amp;rsquo;t involve the web at all. This is possible to do, but involves separating the
two concepts and only combining them at very small seams.&lt;/p&gt;

&lt;p&gt;The actual development of the application logic is very specific to your use case, which makes it hard to offer suggestions on how
to achieve it. However, a general goal should be to have the entire application &amp;ldquo;runnable via CLI.&amp;rdquo; This creates an artificial goal
of not having code that is deeply integrated with being accessed via the web. Another artificial goal is that all tests for the
application should not involve the web at all. There are no &amp;ldquo;controllers&amp;rdquo; nor &amp;ldquo;actions&amp;rdquo; at this point, just your business logic.&lt;/p&gt;

&lt;p&gt;When this is achieved for the business logic, new development questions might be &amp;ldquo;how do we want to name and design this functionality?&amp;rdquo;,
rather than &amp;ldquo;how can I build this functionality in Rails?&amp;rdquo; Abstractions and patterns could be established in the code that aren&amp;rsquo;t
apparent otherwise, due to the artificial web limitations.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/get-your-rails-out/decoupled-design.png" alt="decoupled rails design, small seam" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;Example of Rails design that introduces a low degree of coupling&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;In the above example, a design is proposed that introduces a single seam between a controller (singular) and the application. This
design introduces a very low level of coupling, and the code that is coupled is generic code implemented for all endpoints. In practice,
I&amp;rsquo;ve found that this seam can be as low as three files: routing, request, response.&lt;/p&gt;

&lt;p&gt;The most significant advantage to this design is that the application is completely able to be executed independent of a web request,
maybe the business needs some CLI runners, or a fancy web socket based API. This design would make it possible to implement these
interfaces in a low number of files, without changing the application at all.&lt;/p&gt;

&lt;h2&gt;Creating a seam with Rails&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve made a lot of suggestions about taking your code away from Rails, so it seems that I should advise on how to create a seam
with Rails. Rails still solves a lot of problems that micro-frameworks like Sinatra just don&amp;rsquo;t solve. It&amp;rsquo;s also nice to be able to
use something that Rails provides when you really do need it. For these reasons, I would suggest creating the seam with Rails rather
than creating a seam to another framework. However, there is nothing so far that indicates you need to use Rails for web! Your
entire business logic is represented without Rails web code present, and could be accessed via any type of interface: Rails,
Sinatra, CLI, Websockets, etc.&lt;/p&gt;

&lt;p&gt;One way to interface with Rails is by defining routes in the router, pointed at some controller structure that you desire. A
&lt;a href="https://en.wikipedia.org/wiki/Front_controller" target="_blank"&gt;front controller&lt;/a&gt; becomes a viable choice here, as the single controller/action
creates a very small seam with the application. You could also still approach 1 action per endpoint, but your seam will be much
larger and could be prone to leaking through or being difficult to maintain.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at how you might approach the router:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/application.rb
# Setup your routes via a custom routes file that properly autoloads locally like routes.rb does
config.paths[&amp;quot;config/routes.rb&amp;quot;].unshift(Rails.root.join(&amp;quot;config&amp;quot;, &amp;quot;custom_routes.rb&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/routes.rb
# Integrate your routes via a context adapter
Rails.application.routes.draw do
  RailsAdapters::Routes.define_routes(self)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# lib/rails_adapters/routes.rb
# Define your routes on the context provided

class RailsAdapters::Routes
  def self.define_routes(context)
    new(MyRouter.instance).call(context)
  end

  def intialize(router)
    @router = router
  end

  def call(context)
    @router.routes.each do |route|
      # route.type =&amp;gt; :get | :post | :put | :delete
      # route.path =&amp;gt; &amp;quot;api/money_withdrawls/:id&amp;quot;
      options = { controller: &amp;quot;front&amp;quot;, action: &amp;quot;execute&amp;quot;, executor: route.executor }
      context.send route.type, route.path, options
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/controllers/front_controller.rb
class FrontController &amp;lt; ApplicationController
  def execute # routing happened previously
    request = RailsAdapters::Request.new(self) # request adapter
    response = params[:executor].new(request).call # response adapter
    render json: response, status: response.status # RailsAdapters::Response.new(self).call(response) rather?
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;The three steps I mentioned previously are visible here: routing, request, response.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So far, I&amp;rsquo;ve offered a way to define some routes in a separate place than the routes file. This may not seem great, as there is
not a ton of code, but that is the point! There doesn&amp;rsquo;t need to be a ton of code to create this seam with Rails. With a small
FrontController that can handle the clue between Rails request concepts and responses, we&amp;rsquo;re able to create lightweight adapters.
If we wanted to move this code to something like Sinatra, we would rewrite these adapters only, 0 business logic changes.&lt;/p&gt;

&lt;p&gt;One technique that can really help writing these adapters is the &amp;ldquo;context&amp;rdquo; concept above. By passing &lt;code&gt;self&lt;/code&gt; in as a parameter to
a method, every method on that context will be available in the consuming class. In this way, we could access &lt;code&gt;context.params&lt;/code&gt;,
&lt;code&gt;context.render&lt;/code&gt;, &lt;code&gt;context.get&lt;/code&gt;, etc. The code that is adapting can have full access to the Rails context, without necessarily
being tied to Rails.&lt;/p&gt;

&lt;h2&gt;Wrap it up&amp;hellip;&lt;/h2&gt;

&lt;p&gt;If you approach your business code as a separate entity from your Rails (or framework in general) code, you will be able to
write the code that you &lt;em&gt;want&lt;/em&gt; to write, rather than the code you&amp;rsquo;re &lt;em&gt;forced&lt;/em&gt; to write. Look for design patterns that suit
your needs and make sense in your context. I utilize a &amp;ldquo;front controller&amp;rdquo; pattern, but there are other patterns for web interfaces
that could work for you! If you&amp;rsquo;re tied to The Rails Way, you might miss these patterns and be forced into someone else&amp;rsquo;s
design choices.&lt;/p&gt;
</content>
  </entry>
</feed>

<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen Bussey's Software Engineering Blog</title>
  <id>https://stephenbussey.com</id>
  <link href="https://stephenbussey.com"/>
  <link href="https://stephenbussey.com/feed.xml" rel="self"/>
  <updated>2018-02-06T21:10:00-05:00</updated>
  <author>
    <name>Stephen Bussey</name>
  </author>
  <entry>
    <title>28 Days - Peerage Deep Dive</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/07/peerage-deep-dive.html"/>
    <id>https://stephenbussey.com/2018/02/07/peerage-deep-dive.html</id>
    <published>2018-02-06T21:10:00-05:00</published>
    <updated>2018-02-06T21:32:17-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I am going to continue off of &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;yesterdays&amp;rsquo; post&lt;/a&gt;
in order to look at how the &lt;a href="https://github.com/mrluc/peerage" target="_blank"&gt;Peerage&lt;/a&gt; library works. Peerage
is a pretty awesome library which makes Node discovery in distributed environments very easy.&lt;/p&gt;

&lt;h2&gt;Peerage Strategies&lt;/h2&gt;

&lt;p&gt;Peerage offers &lt;a href="https://github.com/mrluc/peerage#usage" target="_blank"&gt;several strategies&lt;/a&gt; which allow
for Node discovery. The most common one for me has been DNS, but the others can be just
as valuable depending on environment.&lt;/p&gt;

&lt;p&gt;At the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;simplest&lt;/a&gt;, a
Peerage discovery service must respond to the &lt;code&gt;poll()&lt;/code&gt; function. This is a pretty small
interface, which would make creating new discovery strategies very easy. The
&lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;self&lt;/a&gt; strategy only
returns the current node in a List, which is essentially a no-op.&lt;/p&gt;

&lt;p&gt;We can look a little deeper at something that might do some actual connectivity,
the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/list.ex#L28" target="_blank"&gt;list&lt;/a&gt; strategy.
As we can see from this code, it&amp;rsquo;s really not complex. The application is setup with a list
of Node symbols, and those will try to connect through this strategy.&lt;/p&gt;

&lt;p&gt;Now we can finally get into some real work, with the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L45" target="_blank"&gt;UDP strategy&lt;/a&gt;.
UDP can be used to connect in a situation where nodes are on the same network, but are generally
unware of what other nodes are on the network. Digging into the UDP strategy, we can see that
UDP messages are sent over the network, and include the format &lt;code&gt;&amp;quot;Peer#{node()}&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Broadcast our node name via UDP every 3-7 seconds&amp;quot;
def handle_info(:broadcast, state = %{conn: {addr, port, sock}}) do
  :ok = :gen_udp.send(sock, addr, port, [&amp;quot;Peer:#{ node() }&amp;quot;])
  Process.send_after(self(), :broadcast, :rand.uniform(4_000) + 3_000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a UDP packet comes in, matching the format, that node is logged into state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Handle UDP packet. If it&amp;#39;s a node name broadcast, adds to `state.seen`.&amp;quot;
def handle_info({:udp,sock,_,_, &amp;quot;Peer:&amp;quot; &amp;lt;&amp;gt; name}, state = %{seen: ms}) do
  Logger.debug &amp;quot;  -&amp;gt; Peerage.Via.Udp sees: #{ name }&amp;quot;
  :inet.setopts(sock, active: 1)
  {:noreply, %{state | seen: ms |&amp;gt; MapSet.put(name |&amp;gt; String.to_atom)}}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L52" target="_blank"&gt;this state is returned&lt;/a&gt; synchronously
when requested by the poller we saw previously.&lt;/p&gt;

&lt;p&gt;I really like this general approach because we can see that there isn&amp;rsquo;t real magic going on. Nodes
are broadcasting their name over the UDP connectionless protocol, and then letting the polling
service take over from there (which will be explained below).&lt;/p&gt;

&lt;p&gt;Finally, the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L32" target="_blank"&gt;DNS strategy&lt;/a&gt;, can
be used in multi-node situations where IPs are mapped to a DNS record. In kubernetes, for example,
the nodes can be mapped into a headless service and then resolved from there. The poll mechanism
of the DNS strategy is even simpler than UDP. Simply take the provided DNS name, look it up
using &lt;code&gt;:inet_res.lookup(&amp;#39;domain.com&amp;#39;, :in, :a)&lt;/code&gt;, and then &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L38" target="_blank"&gt;turn the provided IPs into connectable
names&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Connection&lt;/h2&gt;

&lt;p&gt;My favorite part of peerage, by far, is how simple the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/server.ex" target="_blank"&gt;server&lt;/a&gt;
is that actually connects nodes together. The polling code triggers the &lt;code&gt;discover&lt;/code&gt; method
and reschedules for some interval in the future. If you haven&amp;rsquo;t seen it before, the
&lt;code&gt;Process.send_after&lt;/code&gt; line here is very common for creating gen servers which do some
regular interval&amp;rsquo;d work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def handle_info(:poll, state) do
  discover()
  Process.send_after(self(), :poll, interval() * 1000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the real simplicity comes out with node connections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp discover do
  poll()
  |&amp;gt; only_fresh_node_names
  |&amp;gt; Enum.map(&amp;amp;([&amp;amp;1, Node.connect(&amp;amp;1)]))
  |&amp;gt; log_results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nodes are polled using the mechanisms we saw previously, then compared against currently
connected nodes. &lt;code&gt;Node.connect&lt;/code&gt; is then called on the symbol provided by the providers, and attempted
to connect to. When a Node connects, erlang handles all of the security and heartbeat, as
laid out in the &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;previous post&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;This simple and elegant library has been a cornerstone for me connecting nodes together in
kubernetes. It is great to see that there is no hacky implementations under the covers. It is
simply easy to follow and debug Elixir code, falling back on known erlang libraries.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 6th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Elixir Node Networking Basics</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html"/>
    <id>https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html</id>
    <published>2018-02-05T21:08:00-05:00</published>
    <updated>2018-02-06T00:17:22-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;One of my favorite points in Elixir, some form of magic perhaps, is how simple
distributed networking can be. The language itself seems to make establishing
networked nodes and sending messages a pain-free exercise. While breaking down
networking techniques is more than a single post, I am going to look into some of
the basics of networking in Elixir. Specifically, what happens when we connect
nodes together?&lt;/p&gt;

&lt;h2&gt;Nodes in Elixir&lt;/h2&gt;

&lt;p&gt;In Elixir, a &lt;code&gt;Node&lt;/code&gt; could be defined as a single running instance. There can be
multiple nodes running on a single machine. Let&amp;rsquo;s use this to take a look at some
basics of node communication, before diving into what is going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
iex --name test@127.0.0.1

# In shell 2
iex --name test2@127.0.0.1

# In shell 1
Node.self() # :&amp;quot;test@127.0.0.1&amp;quot;
Node.list() # []
Node.connect(:&amp;quot;test2@127.0.0.1&amp;quot;) # true
Node.list() # [:&amp;quot;test2@127.0.0.1&amp;quot;]

# In shell 2
Node.list() # [:&amp;quot;test@127.0.0.1&amp;quot;]

# Leave open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above interactive example, it&amp;rsquo;s possible to see that 2 nodes are initially
started, with a particular name of &lt;code&gt;test@127.0.0.1&lt;/code&gt; or test2. These nodes start as
disconnected, but can be manually connected. Once connected, both nodes are aware of the
other node&amp;rsquo;s existence.&lt;/p&gt;

&lt;p&gt;Finally, we can test out sending a message in the above processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
Node.spawn(:&amp;quot;test2@127.0.0.1&amp;quot;, fn -&amp;gt; IO.inspect(Node.self()) end)
#PID&amp;lt;13084.113.0&amp;gt;
:&amp;quot;test2@127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, a function is set to be executed on &lt;code&gt;:&amp;quot;test2@127.0.01&amp;quot;&lt;/code&gt;. We can see
that the result of the execution is a remote pid (doesn&amp;rsquo;t start with 0) as well the output
containing the node&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;The Node module contains lots of interesting tidbits that are actually implemented pretty
thin on top of erlang modules. This post won&amp;rsquo;t go into the ins and outs of node communication,
although it&amp;rsquo;s suffice to say that communication is generally done in better ways than
spawning functions between the nodes.&lt;/p&gt;

&lt;h2&gt;Diving into a connection&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/node.ex#L150" target="_blank"&gt;Node.connect&lt;/a&gt; provides
a really simple 1-liner over &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;. Let&amp;rsquo;s dig into this function and
what some ramifications of using it are.&lt;/p&gt;

&lt;p&gt;Deep inside of the erlang OTP libraries, we start to see some interesting code in connection.
Specifically, there is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L313" target="_blank"&gt;code&lt;/a&gt;
to handle automatic &amp;ldquo;magical&amp;rdquo; connection between nodes, vs more explicit connection dependencies.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L342" target="_blank"&gt;Digging even further&lt;/a&gt;,
we discover that the &lt;code&gt;net_kernel&lt;/code&gt; symbol is actually a process on the system. Running &lt;code&gt;Process.whereis(:net_kernel)&lt;/code&gt;
will return the pid of this net_kernel process.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L422" target="_blank"&gt;The first time that a Node is connected to&lt;/a&gt;,
that connection is not present in the ets lookup table. This leads to setup being called and
initializing that connection.&lt;/p&gt;

&lt;p&gt;By digging into &lt;code&gt;Process.whereis(:net_kernel) |&amp;gt; :sys.get_state()&lt;/code&gt;, it&amp;rsquo;s possible to see that
there is a structure like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:listen, #Port&amp;lt;0.609&amp;gt;, #PID&amp;lt;0.49.0&amp;gt;,
    {:net_address, {{0, 0, 0, 0}, 56479}, &amp;#39;Steves-MBP&amp;#39;, :tcp, :inet},
    :inet_tcp_dist}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This state is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L113" target="_blank"&gt;documented&lt;/a&gt;
and helps to let us trace the module that will actually connect our nodes together. Finally, we
are able to track down the &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/inet_tcp_dist.erl#L296" target="_blank"&gt;setup code&lt;/a&gt;
that is creating the TCP socket between the nodes.&lt;/p&gt;

&lt;p&gt;One small caveat of connecting to nodes is that &amp;ldquo;cookies&amp;rdquo; have to match up. This is
essentially an atom that is initialized on boot and read from &lt;code&gt;~/.erlang.cookie&lt;/code&gt;. Finding
this was pretty challenging in erlang, but I traced it back to
&lt;a href="https://github.com/erlang/otp/blob/d99803e7625e474dee40f0dfebf2b8092add0336/lib/kernel/src/dist_util.erl#L216" target="_blank"&gt;dist_util&lt;/a&gt;
module. The code above (even if you can&amp;rsquo;t read erlang) is doing some interesting challenge/reply
protocol to ensure that the nodes are allowed to talk to each other.&lt;/p&gt;

&lt;h2&gt;After the connection&lt;/h2&gt;

&lt;p&gt;Of course, connecting via TCP here is just the beginning. There is significantly more
at play, cookies to authenticate nodes and heartbeats to ensure connectivity between nodes
for starters. The &lt;a href="http://learnyousomeerlang.com/distribunomicon" target="_blank"&gt;distributed erlang guide&lt;/a&gt; from
learnyousomeerlang.com goes over some of these concepts in detail. I&amp;rsquo;ll be tackling them
in a future post as well.&lt;/p&gt;

&lt;h2&gt;Addendum&lt;/h2&gt;

&lt;p&gt;It was asked in the Elixir slack group if it&amp;rsquo;s possible to customize the distribution mechanism
from TCP/IP to something else. It is! It&amp;rsquo;s fairly involved C code, but there is &lt;a href="http://erlang.org/doc/apps/erts/alt_dist.html" target="_blank"&gt;an example&lt;/a&gt;
walking through a OS socket level distribution.&lt;/p&gt;

&lt;p&gt;In addition, some other drivers are provided out of the box, such as a
&lt;a href="http://erlang.org/doc/apps/ssl/ssl_distribution.html" target="_blank"&gt;SSL driver&lt;/a&gt; for communicating
over SSL.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;I don&amp;rsquo;t really read erlang code, so this post was very interesting today. However, a lot
of great things can be learned from digging into the erlang code and module documentation
and not relying solely on Elixir docs. For instance, the documentation for node networking
brings up great points around security and TLS node communication. Dive into the docs and
see what you go from there; it might be useful one day when there&amp;rsquo;s a problem that you
just can&amp;rsquo;t figure out.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 5th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Sourcing Libraries from Private Github</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html"/>
    <id>https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html</id>
    <published>2018-02-04T19:57:00-05:00</published>
    <updated>2018-02-04T20:29:42-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Hex is currently working on &lt;a href="https://hex.pm/docs/private" target="_blank"&gt;private organizations&lt;/a&gt; which
are in beta. Until the full details of those are public and available, you may find
yourself needing to source Elixir libraries privately. You may also just desire a quick
fix and not setting up private packages. Enter git sourced packages.&lt;/p&gt;

&lt;h2&gt;Mix and Git&lt;/h2&gt;

&lt;p&gt;At the simplest form, you can think of git sourced dependencies as a clone of the provided
repo using system git. In fact, the implementation is
a &lt;a href="https://github.com/elixir-lang/elixir/blob/f77cc2657cf981fdf819915f1ee15e69c3cd91ad/lib/mix/lib/mix/scm/git.ex#L250" target="_blank"&gt;shell out to git&lt;/a&gt;.
This means any repo which a system can access will be accessible via git, including
repos which are locked behind private access.&lt;/p&gt;

&lt;p&gt;I have seen tags work as a good way to mark the versions in the git repo. The form looks
something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: &amp;quot;v1.0.0&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above mix.exs entry will fetch the mix package named &lt;code&gt;:my_dependency_name&lt;/code&gt; from git@github.com:Organization/repo.git,
commit tagged v1.0.0. &lt;a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank"&gt;Github SSH&lt;/a&gt; access
is used due to the repo being &lt;code&gt;git@github.com&lt;/code&gt; format.&lt;/p&gt;

&lt;h2&gt;Trickery with Docker and CI&lt;/h2&gt;

&lt;p&gt;This all works well locally. In fact, just following the standard tutorial will lead to a working
private dependency, locally. Things get a bit trickier when something like Docker or a build
server is used to fetch your dependency. In this situation, the SSH key of each system would need
to be included on Github. Another difficulty is that Docker containers have to have SSH keys added
to them, they don&amp;rsquo;t come with them standard. All of this leads to another possible solution:
accessing Github via API keys.&lt;/p&gt;

&lt;h2&gt;API Key Setup&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/blog/1509-personal-api-tokens" target="_blank"&gt;Github personal access tokens&lt;/a&gt; can be used
to access certain parts of Github, such as repository access. In order to use one with mix,
just switch out the git url from &lt;code&gt;git@github.com:Organization/repo.git&lt;/code&gt; to
&lt;code&gt;https://#{access_token}@github.com/Organization/repo&lt;/code&gt;. With this solution, any access token
which has read access to the repo will serve as the access into Git.&lt;/p&gt;

&lt;p&gt;There does exist a drawback with this solution, the access token would need to be provided to
every user of the application. This is non-desirable as the access token should really be kept
secret, even to the point of being encrypted docker arguments. With a small tweak, it is possible to
achieve the best of both worlds, SSH locally but access tokens for Docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp deps do
  [
    {:phoenix, &amp;quot;~&amp;gt; 1.3.0&amp;quot;},
  ] ++ private_deps(System.get_env(&amp;quot;MIX_GITHUB_ACCESS_TOKEN&amp;quot;))
end

@my_dependency_version &amp;quot;v1.0.0&amp;quot;

defp private_deps(nil) do
  [
    {:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: @my_dependency_version},
  ]
end

defp private_deps(access_token) do
  [
    {:my_dependency_name, git: &amp;quot;https://#{access_token}@github.com/Organization/repo&amp;quot;, tag: @my_dependency_version},
  ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will append the private dependencies into the deps list, but do so with
either SSH or access token access. Dependency versions should always be constant, so
it is pulled into an attribute.&lt;/p&gt;

&lt;p&gt;One caveat with this approach is that each mix invocation must contain the ENV, not
just &lt;code&gt;deps.get&lt;/code&gt;. This is due to the mix.lock being checked when mix runs, and the
correct dependencies are pulled each time through the above code path.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;With the presented approach, there should be little trouble getting private repos
both locally and in CI, without compromise on security of your keys. If the straight access
token route is taken, take extra care regarding the permissions of the account behind
the key.&lt;/p&gt;

&lt;p&gt;Thanks for reading the fourth post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate the posts to get more and more technical as the time goes on!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Bringing Elixir to Others - New Language vs. New Paradigm</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html"/>
    <id>https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html</id>
    <published>2018-02-03T14:46:00-05:00</published>
    <updated>2018-02-03T15:10:05-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;ll be giving a talk next week about taking Elixir into production. While there are
technical challenges to doing so, I must also consider the human-based challenges that will be faced. For
example, most team members will be learning a new language when they are introduced to Elixir.
If they have been doing object-oriented coding, will a functional coding paradigm get them stuck?
Will OTP and the paradigm of a process based application cause confusion?&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t necessarily present answers to some of these questions today, but rather bring up
questions that I&amp;rsquo;ve heard and alternative ways of thinking about the answers.&lt;/p&gt;

&lt;h2&gt;Functional Programming and Elixir Itself&lt;/h2&gt;

&lt;p&gt;Before all of the fun and excitement of making a real Elixir application comes the challenge of
learning the Elixir language. Most people that ask me about learning Elixir focus on what
types of courses they can pay for online to get into the language. While I&amp;rsquo;m sure that some
people are going to benefit from these courses enormously, it&amp;rsquo;s never the first place I&amp;rsquo;d send
someone. Instead, I recommend the &lt;a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank"&gt;Elixir Getting Started Guide&lt;/a&gt;.
This guide is put together by the official Elixir team and covers an introduction to the language itself.&lt;/p&gt;

&lt;p&gt;As other members of the organization dive into the concepts of Elixir, questions will
be raised about what functional programming is, what does immutability mean, and what is &amp;ldquo;all of this&amp;rdquo; in practice?
Even further questioning might ask &amp;ldquo;what makes the functional paradigm good?&amp;rdquo; Other team members will rely
on the Elixir champion to answer these questions, so be prepared for them to pop up once people start learning.
I read something in a reddit comment today that I really liked on this topic: the value of the data
doesn&amp;rsquo;t change in Elixir, but rather the variables point to new pieces of data. I thought that was a
very straight-forward way of looking at the functional programming model that Elixir brings.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I prep anyone that is going through the getting started guide that it will take probably 2-4 times
to really understand Elixir to the point of being comfortable when reading other people&amp;rsquo;s code. Having
a real world project to read and play around with can lower this learning curve.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;OTP&lt;/h2&gt;

&lt;p&gt;OTP is a cornerstone of writing Elixir applications. There&amp;rsquo;s lot of things about the topic already, but
I had an interesting observation the other day about OTP and how it relates to bringing Elixir to the
rest of an organization:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The majority of business applications could be built with all OTP hidden away by libraries, to the point
of developers not needing to know the details of OTP.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While I think that using OTP can help bring about advantages in an application, especially in a distributed
environment, it is not really necessary. For example, a developer could start a new application today and
serve the HTTP layer with Phoenix. They could then spin up a queue system like ExQ in order to process
background jobs. Finally, they can connect websockets for read/write access to the API. All of this can happen
without ever typing &lt;code&gt;GenServer&lt;/code&gt; in code and create an application which satisfies the business.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t necessarily best practice, but I believe that it&amp;rsquo;s okay to sometimes put aside best practice
in order to achieve an initial velocity. Once the team is rolling, the OTP concepts will come out of the
woodwork and start to make sense, hopefully faster than they would in isolation.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Regardless of how you approach bringing Elixir to the people on your team, realize that you must be a
champion for the education and empowerment of the team. Look for interesting ways to answer questions that
people have and remove the roadblocks that pop-up as quick as you can.&lt;/p&gt;

&lt;p&gt;Thanks for reading the third post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Silly Mistakes I Make Again and Again</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html"/>
    <id>https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html</id>
    <published>2018-02-02T01:30:00-05:00</published>
    <updated>2018-02-02T02:10:29-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;It&amp;rsquo;s day 2 of my 28 days of Elixir blogging. I have 5 more ideas in the funnel, and I fear
that coming up with 28 interesting topics will be hard. I&amp;rsquo;ll definitely be leaning on
co-workers for ideas, but don&amp;rsquo;t hesitate to reach out if you have any interesting ideas
that you&amp;rsquo;d want me to explore!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been writing Elixir daily at SalesLoft, and have gotten pretty quick with development
and testing of my apps. However, a few things just keep catching me up every time:&lt;/p&gt;

&lt;h2&gt;Charlist and Strings&lt;/h2&gt;

&lt;p&gt;In both Ruby and Javascript, it is acceptable to swap &amp;lsquo; and &amp;ldquo;  for strings, in many cases.
This means that &amp;#39;a&amp;rsquo; === &amp;quot;a&amp;rdquo; in Javascript. However, &amp;lsquo;a&amp;rsquo; != &amp;ldquo;a&amp;rdquo; in Elixir. This is due to
charlist and string being implemented differently. Charlist is often used for interfacing
with erlang directly, because erlang does not have the concept of &amp;ldquo;strings&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;One mistake I will often catch is swapping the usage of the quote constructs and then
doing equality or other comparisons, and being bewildered when the strings do not match.
Catching this error can be a bit tricky if the error message doesn&amp;rsquo;t show you that the
types are different, but a usual symptom is being completely bewildered why two matching
strings are not matching. The most significant place to pay attention to is when interfacing
with code between libraries, as the target and source are separated.&lt;/p&gt;

&lt;h2&gt;Running mix test on the source file&lt;/h2&gt;

&lt;p&gt;This one is always a face-palmer. When running &lt;code&gt;mix test test/my_test.exs&lt;/code&gt;, be careful of
accidentally copying a path like &lt;code&gt;mix test lib/my.ex&lt;/code&gt;. The symptom of this mistake is a
passing spec suite which runs 0 specs, and complains about a re-defined module.&lt;/p&gt;

&lt;h2&gt;Define a test file with the same name as the real module, rather than test&lt;/h2&gt;

&lt;p&gt;My flow for creating a module is to create the source module (.ex), then running
(opt-g-t) to create a test script (.exs). I will then copy the source module definition
and add ExUnit and &lt;code&gt;Test&lt;/code&gt; to the end of the module.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;m going red/green on my code, I sometimes find myself shocked that a function
doesn&amp;rsquo;t exist when I most certainly just defined it. After looking around wondering
what is going on, I realize I forgot to include &lt;code&gt;Test&lt;/code&gt; at the end of the module. This
re-initializes the module (without real code) but is still a sementically valid
test file.&lt;/p&gt;

&lt;h2&gt;Not recognizing pattern matching in test helpers such as assert received&lt;/h2&gt;

&lt;p&gt;This is one of the more interesting / subtle mistakes that I find myself making. I especially
see this in older Elixir code that I wrote where I didn&amp;rsquo;t fully understand what was
going on.&lt;/p&gt;

&lt;p&gt;I will be doing a task like writing / testing a websocket channel and find that my
code passes perfectly when I know that it&amp;rsquo;s definitely not working correctly. I will
be trying to make my code go red but simply can&amp;rsquo;t make it. Usually, it turns out
that I&amp;rsquo;m using a function like &lt;a href="https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html#assert_push/3" target="_blank"&gt;assert_push/3&lt;/a&gt;
that is actually a macro. The way these are written, the function is actually
doing pattern matching rather than exact checks. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is different than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, ^expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is highlighted in the assert_push documentation, but essentially the first example
doesn&amp;rsquo;t check that the payload is &lt;em&gt;exactly&lt;/em&gt; the expected payload. This means that there could
be something like a data leak and our test wouldn&amp;rsquo;t catch it! Pattern matching the responses
can be super useful, but make sure that it&amp;rsquo;s happening when you expect it, and not
when you don&amp;rsquo;t!&lt;/p&gt;

&lt;p&gt;Thanks for reading, today. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Development Environment</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html"/>
    <id>https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html</id>
    <published>2018-02-01T01:30:00-05:00</published>
    <updated>2018-02-02T01:41:19-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Welcome to day 1 of (hopefully) 28 days of Elixir! I&amp;rsquo;ve set a goal to write a technical blog
post every single day this month, and I&amp;rsquo;m really excited about Elixir right now. I don&amp;rsquo;t know
what the entire series will bring, but I do know that I&amp;rsquo;ll basically have to be putting all of my
thoughts and experiences about Elixir out there over the next month.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to start this series off with something light: development environments. Specifically,
the one that I use and things that I&amp;rsquo;ve found enjoyable coming from another language like Ruby
or Javascript. I don&amp;rsquo;t intend to convince anyone of anything on this (especially with regards
to editors), but I do think there&amp;rsquo;s some interesting things about Elixir specifically that
can apply to every environment. Let&amp;rsquo;s jump in.&lt;/p&gt;

&lt;h2&gt;Elixir Installation&lt;/h2&gt;

&lt;p&gt;I use &lt;a href="https://github.com/taylor/kiex" target="_blank"&gt;kiex&lt;/a&gt; to manage my elixir versions
and &lt;a href="https://github.com/kerl/kerl" target="_blank"&gt;kerl&lt;/a&gt; to manage my erlang/OTP versions. kiex has
been great, it&amp;rsquo;s really easy to use! I have to say that I&amp;rsquo;m genuinely impressed with
how little speed bumps I&amp;rsquo;ve encountered over time. I do recommend using some sort of
version manager rather than brew, because there will definitely be more than one project
in Elixir over time!&lt;/p&gt;

&lt;p&gt;kerl on the other hand, has generally been fairly painful to use. I think the biggest
thing here is that Elixir versions need recompiled once OTP is changed. I could be
wrong here because I haven&amp;rsquo;t had to do it too often, but I do distinctly remember
significant pain from the OTP 20 upgrade. This happens very infrequently though.&lt;/p&gt;

&lt;p&gt;One thing that I wish kiex had was the concept of a .elixir-version file like rbenv. It
has to be done manually right now, which is error prone on a team.&lt;/p&gt;

&lt;h2&gt;My Editor&lt;/h2&gt;

&lt;p&gt;Although I&amp;rsquo;ve tried to get into other editors over time, I have found myself drawn again
and again to the simplicity and flexibility of atom, so that&amp;rsquo;s what I&amp;rsquo;ve been using lately.
There are 3 packages that I use specifically for atom that are, I think, absolute
must haves: atom-elixir, language-elixir, elixir-jump-around.&lt;/p&gt;

&lt;p&gt;atom-elixir and language-elixir provide the base for the actual act of authoring code.
The auto-complete functionality works generally well, although there are some core quirks.
Due to how Elixir compilation works, tools like atom-elixir look into the actual _build
output of the code to produce auto-complete and documentation services. This is really interesting
to me, because it means that &lt;em&gt;any&lt;/em&gt; editor should be able to accomplish that same task. Whether
emacs, vim, vscode, whatever is being used, it should be completely achievable to have full
auto-complete and documentation capabilities.&lt;/p&gt;

&lt;p&gt;In addition to great auto-complete capabilities, atom-elixir has a really good &amp;ldquo;go to definition&amp;rdquo;
functionality. When I am authoring Ruby code, I find that only Rubymine has been able to
achieve true definition jumping. ctags can provide some of it, but jumping into installed
libraries is very useful for debugging problems or understanding how a method works. For example,
do you want to know how an Enum method is implemented? Just alt+click and you&amp;rsquo;re there! Elixir&amp;rsquo;s
compilation design makes this all possible in any editor, not just a Jetbrains editor. Check
it out!&lt;/p&gt;

&lt;p&gt;Lastly, &amp;ldquo;jump to test&amp;rdquo; is so useful for me. My typical flow for creating a file has become:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create the module in my lib folder somewhere&lt;/li&gt;
&lt;li&gt;Press opt-g-t to jump to the non-existent file&lt;/li&gt;
&lt;li&gt;Copy the module definition, add Test to it, then save the file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m able to do this entire flow very quickly and without navigating a file tree.&lt;/p&gt;

&lt;h2&gt;Docker vs Native Execution&lt;/h2&gt;

&lt;p&gt;Some people really like to develop software on the OS that is going to run it in production,
and more power to them! However, I&amp;rsquo;ve found myself drawn to having software that is runnable
on my macbook, natively, rather than using a tool like Docker or Vagrant. However, I do utilize
Docker for CI and production build processes.&lt;/p&gt;

&lt;h2&gt;Mix Format&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve begrudgingly accepted the mix formatter over the past few weeks. I find that I often
have issues with getting a file to format in certain situations. This seems like a bug in the formatter,
though. The format itself is generally agreeable but sometimes is not and there is no
customization route. I think that it&amp;rsquo;s better to accept a standard, even if it&amp;rsquo;s not
my desired standard, if it improves the community and team at large.&lt;/p&gt;

&lt;p&gt;I run this manually as I go. Now that I think about it more, I should probably have this setup
in some semi-automated fashion until it becomes too slow.&lt;/p&gt;

&lt;h2&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;That ended up being longer than I anticipated, but I&amp;rsquo;m still sure there are many things
I didn&amp;rsquo;t cover. Feel free to reach out if you have any question about how my setup
works or if you have awesome tools that you can&amp;rsquo;t live without!&lt;/p&gt;

&lt;p&gt;See ya tomorrow hopefully! It is only day 1, so we&amp;rsquo;ll have to see how it goes.&lt;/p&gt;
</content>
  </entry>
</feed>

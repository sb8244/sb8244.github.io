<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen Bussey's Software Engineering Blog</title>
  <id>https://stephenbussey.com</id>
  <link href="https://stephenbussey.com"/>
  <link href="https://stephenbussey.com/feed.xml" rel="self"/>
  <updated>2018-02-08T22:20:00-05:00</updated>
  <author>
    <name>Stephen Bussey</name>
  </author>
  <entry>
    <title>28 Days - Demo - Single process in a distributed system</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/09/demo-explanation-single-process-in-a-distributed-system.html"/>
    <id>https://stephenbussey.com/2018/02/09/demo-explanation-single-process-in-a-distributed-system.html</id>
    <published>2018-02-08T22:20:00-05:00</published>
    <updated>2018-02-08T23:37:33-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;m really excited about this post, I&amp;rsquo;ve been thinking about what the demo will
look like for several days, but it turned out differently than I had in my head.
I&amp;rsquo;m writing this from 35k feet on my way to vacation; there&amp;rsquo;s nothing better than
being on a plane to hash out technical problems that have been put off. It would
be great if the wifi worked though&amp;hellip;&lt;/p&gt;

&lt;p&gt;Today&amp;rsquo;s post is going to be a demo + walkthrough of creating a singular process
chokepoint in a distributed system. That might not be the best way to explain it, but
I&amp;rsquo;m also struggling to find a better explanation. The end goal is that in a cluster
of 3 nodes, I can say &amp;ldquo;request id 1&amp;rdquo; and have that go to node 1 every time. I can say
&amp;ldquo;request id 3&amp;rdquo; and have that go to node 3.&lt;/p&gt;

&lt;h2&gt;Code / Demo&lt;/h2&gt;

&lt;p&gt;The code is found at &lt;a href="https://www.github.com/sb8244/distributed_process_demo" target="_blank"&gt;https://www.github.com/sb8244/distributed_process_demo&lt;/a&gt;.
The repo has instructions for the actual demo and how it should be run.&lt;/p&gt;

&lt;p&gt;This code is in the intermediate category, probably. However, it&amp;rsquo;s short and the
tools used are core for building Elixir apps. Don&amp;rsquo;t be shy to dig in and break it
locally to really learn what&amp;rsquo;s going on!&lt;/p&gt;

&lt;h2&gt;How it works&lt;/h2&gt;

&lt;p&gt;Elixir has the ability to connect to other nodes that are accessible on the network. We
can use this to spawn several local nodes that simulate a networked environment. The
&lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process.ex#L4" target="_blank"&gt;&lt;code&gt;DistributedProcess.connect()&lt;/code&gt;&lt;/a&gt;
function iterates on up to 5 known node names and connects to them. This is a quick hack to get them connected.&lt;/p&gt;

&lt;p&gt;The application creates two different top level supervisors, a &lt;code&gt;Registry&lt;/code&gt; which allows
unique storage of processes (unique by ID here) and a &lt;code&gt;DistributedProcess.Supervisor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process/supervisor.ex" target="_blank"&gt;&lt;code&gt;DistributedProcess.Supervisor&lt;/code&gt;&lt;/a&gt;
does the majority of the work for distributing our
process across the cluster. It accepts an &lt;code&gt;id&lt;/code&gt; into the &lt;code&gt;get_worker/1&lt;/code&gt; function, and
uses a modulo operator on the number of nodes to determine which node will be the lucky
receiver of this request. The size of a node is fairly consistent in practice, so this
seems acceptable for starters.&lt;/p&gt;

&lt;p&gt;When the right node is chosen, the &lt;code&gt;DynamicSupervisor.start_child&lt;/code&gt; call creates an instance
of a &lt;code&gt;DistributedProcess.Worker&lt;/code&gt; on the local or remote chosen node. This Worker is setup to
be unique based on the ID. This is really helpful as it allows future calls to the same ID
to return the same process.&lt;/p&gt;

&lt;p&gt;Once a local or remote pid is returned from the DynamicSupervisor, that pid has a &lt;code&gt;call&lt;/code&gt; request
execute against it. &lt;code&gt;call&lt;/code&gt; will return an answer synchronously, which is great for the purposes
of this demo.&lt;/p&gt;

&lt;p&gt;In the &lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process/worker.ex" target="_blank"&gt;&lt;code&gt;DistributedProcess.Worker&lt;/code&gt;&lt;/a&gt;,
the first thing is does is actually tell itself to be destroyed
in 5 seconds. This is to make the demo interesting, but also simulates the use case of a short
lived cache.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;handle_call(:request)&lt;/code&gt; function in the worker does 2 different things, for 2 different
function heads. The first is if there is a value in the local state. Then it is simply
returned as is. The second is if there is no value in the local state. A random 1-1000
integer is selected and placed in the state, along with the node name. This allows us to see
that the data is in fact changing every 5 seconds, and where it came from.&lt;/p&gt;

&lt;p&gt;All of this is packaged up into 2 top level functions that are called: &lt;code&gt;DistributedProcess.connect()&lt;/code&gt;
and &lt;code&gt;DistributedProcess.request(id)&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Use Case&lt;/h2&gt;

&lt;p&gt;It may be desirable to have a single choke point across a cluster to handle a single
type of request. For instance, maybe a certain tenant should only execute on a single
server. This ensures that the requests for that tenant are serial (non-parallel).&lt;/p&gt;

&lt;p&gt;My use case is to cache requests to a certain resource/id pair for 30-60 seconds. I want
to make a single request, then return that value for the lifetime of it. I do not
want to introduce a DB layer just for this caching, as maintaining that is prone to
easier logic errors around cache expiration and checking.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m most excited about how this code doesn&amp;rsquo;t really feel remote. It can run on a
local system just as well as in a clustered system, and it scales with cluster size
with no additional work. That is pretty fun!&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know how I would easily test this code. Not having internet led me to not
test this code today. However, I will probably look into how I can test it and write
about that in the future. I have had several requests for testing posts, especially
if they involve complex setups.&lt;/p&gt;

&lt;p&gt;I do not know, yet, how I would handle a situation of fetching an array of ids. I would
want the cache to be distributed, but there is a challenge in not having the same id
set each time. This sort of breaks the technique, but it doesn&amp;rsquo;t mean it&amp;rsquo;s not valuable
for single / deterministic ids.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Thanks to my co-worker Ben for bouncing this idea around at SalesLoft. We haven&amp;rsquo;t placed
the technique in production yet, but him and I were both really excited to talk about it.
I&amp;rsquo;m curious to see how he would approach this type of problem, as I know he had more
elegant solutions in mind.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 8th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am looking for new topics to write about, so please reach out if there&amp;rsquo;s anything you
really want to see!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - The Beauty of Macros</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/08/the-beauty-of-macros.html"/>
    <id>https://stephenbussey.com/2018/02/08/the-beauty-of-macros.html</id>
    <published>2018-02-07T22:31:00-05:00</published>
    <updated>2018-02-07T22:48:55-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;m aiming for a shorter post today, as I presented a 50 minute talk about &amp;ldquo;Elixir in Production&amp;rdquo;
at the Atlanta Elixir Meetup tonight. I&amp;rsquo;m proud of how the talk turned out, but I&amp;rsquo;m
also looking forward to hearing what content will make it better, and submitting it
to conferences.&lt;/p&gt;

&lt;p&gt;For the end of the first week (7th day) of Elixir writing, I wanted to break down a
small chunk of code that I recently wrote that utilizes macros. In particular,
there&amp;rsquo;s a cool property of macros that I want to explain. Let&amp;rsquo;s just go into the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule SalesloftApi.Phoenix.Router do
  defmacro setup({:__aliases__, _ctx, module_path}, controller) do
    router_module = Module.concat(module_path)

    router_module.min_api_version()..router_module.current_api_version()
    |&amp;gt; Enum.flat_map(fn api_version -&amp;gt;
      router_module.routes()
      |&amp;gt; Map.values()
      |&amp;gt; Enum.map(fn route = %{http_verb: verb} -&amp;gt;
        path = SalesloftApi.Route.path(route)

        quote do
          scope &amp;quot;/v#{unquote(api_version)}&amp;quot; do
            unquote(verb)(unquote(path), unquote(controller), :execute, assigns: %{route: unquote(Macro.escape(route))})
          end
        end
      end)
    end)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For context, this code is an adapter to convert between a router module and phoenix routes.
We are doing this in order to provide our API at a level outside of just HTTP (like websockets or
console) and to ensure that we can control how the API is documented at a very native
level. I previous &lt;a href="/2017/09/04/get-your-rails-out-of-my-ruby-http.html" target="_blank"&gt;wrote&lt;/a&gt; about a similar
concept in Ruby.&lt;/p&gt;

&lt;p&gt;This code is a macro which accepts a module and a controller module into it. It&amp;rsquo;s intended to be
called from a Phoenix.Router module.&lt;/p&gt;

&lt;p&gt;The code follows this simplified flow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Iterate over available versions of the API (2-&amp;gt;2 currently)&lt;/li&gt;
&lt;li&gt;Iterate over the available routes&lt;/li&gt;
&lt;li&gt;Generate some Phoenix.Router compatible code like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;scope &amp;quot;/v2&amp;quot; do
  get(&amp;quot;/widgets&amp;quot;, FrontController, :execute, assigns: %{route: route})
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Provide the generated code as the macro&amp;rsquo;s return.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is my &lt;strong&gt;favorite&lt;/strong&gt; part of this code: it doesn&amp;rsquo;t know what phoenix is. This project
does not take phoenix in as a dependency&amp;hellip;you don&amp;rsquo;t need to use phoenix to use this module.
What needs to happen is that there must be code that supports &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt;/friends in
the module that calls this. It just happens to be phoenix.&lt;/p&gt;

&lt;p&gt;This captures the flexibility of Elixir very concisely. The code that a macro generates is
&amp;ldquo;placed into&amp;rdquo; the call site, and the original library doesn&amp;rsquo;t execute that code.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;If you do decide to learn what macros are about, I can&amp;rsquo;t recommend
&lt;a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir" target="_blank"&gt;Metaprogramming Elixir&lt;/a&gt; enough.
I found the book to be excellent at highlighting how macros are really used in the
Elixir code that I use daily.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 7th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am leaving for vacation tomorrow. I&amp;rsquo;m excited for the time to reflect on interesting topics and
to have more time in the evening to write about them&amp;hellip;hopefully. Cheers!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Peerage Deep Dive</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/07/peerage-deep-dive.html"/>
    <id>https://stephenbussey.com/2018/02/07/peerage-deep-dive.html</id>
    <published>2018-02-06T21:10:00-05:00</published>
    <updated>2018-02-06T21:32:17-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I am going to continue off of &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;yesterdays&amp;rsquo; post&lt;/a&gt;
in order to look at how the &lt;a href="https://github.com/mrluc/peerage" target="_blank"&gt;Peerage&lt;/a&gt; library works. Peerage
is a pretty awesome library which makes Node discovery in distributed environments very easy.&lt;/p&gt;

&lt;h2&gt;Peerage Strategies&lt;/h2&gt;

&lt;p&gt;Peerage offers &lt;a href="https://github.com/mrluc/peerage#usage" target="_blank"&gt;several strategies&lt;/a&gt; which allow
for Node discovery. The most common one for me has been DNS, but the others can be just
as valuable depending on environment.&lt;/p&gt;

&lt;p&gt;At the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;simplest&lt;/a&gt;, a
Peerage discovery service must respond to the &lt;code&gt;poll()&lt;/code&gt; function. This is a pretty small
interface, which would make creating new discovery strategies very easy. The
&lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;self&lt;/a&gt; strategy only
returns the current node in a List, which is essentially a no-op.&lt;/p&gt;

&lt;p&gt;We can look a little deeper at something that might do some actual connectivity,
the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/list.ex#L28" target="_blank"&gt;list&lt;/a&gt; strategy.
As we can see from this code, it&amp;rsquo;s really not complex. The application is setup with a list
of Node symbols, and those will try to connect through this strategy.&lt;/p&gt;

&lt;p&gt;Now we can finally get into some real work, with the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L45" target="_blank"&gt;UDP strategy&lt;/a&gt;.
UDP can be used to connect in a situation where nodes are on the same network, but are generally
unware of what other nodes are on the network. Digging into the UDP strategy, we can see that
UDP messages are sent over the network, and include the format &lt;code&gt;&amp;quot;Peer#{node()}&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Broadcast our node name via UDP every 3-7 seconds&amp;quot;
def handle_info(:broadcast, state = %{conn: {addr, port, sock}}) do
  :ok = :gen_udp.send(sock, addr, port, [&amp;quot;Peer:#{ node() }&amp;quot;])
  Process.send_after(self(), :broadcast, :rand.uniform(4_000) + 3_000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a UDP packet comes in, matching the format, that node is logged into state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Handle UDP packet. If it&amp;#39;s a node name broadcast, adds to `state.seen`.&amp;quot;
def handle_info({:udp,sock,_,_, &amp;quot;Peer:&amp;quot; &amp;lt;&amp;gt; name}, state = %{seen: ms}) do
  Logger.debug &amp;quot;  -&amp;gt; Peerage.Via.Udp sees: #{ name }&amp;quot;
  :inet.setopts(sock, active: 1)
  {:noreply, %{state | seen: ms |&amp;gt; MapSet.put(name |&amp;gt; String.to_atom)}}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L52" target="_blank"&gt;this state is returned&lt;/a&gt; synchronously
when requested by the poller we saw previously.&lt;/p&gt;

&lt;p&gt;I really like this general approach because we can see that there isn&amp;rsquo;t real magic going on. Nodes
are broadcasting their name over the UDP connectionless protocol, and then letting the polling
service take over from there (which will be explained below).&lt;/p&gt;

&lt;p&gt;Finally, the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L32" target="_blank"&gt;DNS strategy&lt;/a&gt;, can
be used in multi-node situations where IPs are mapped to a DNS record. In kubernetes, for example,
the nodes can be mapped into a headless service and then resolved from there. The poll mechanism
of the DNS strategy is even simpler than UDP. Simply take the provided DNS name, look it up
using &lt;code&gt;:inet_res.lookup(&amp;#39;domain.com&amp;#39;, :in, :a)&lt;/code&gt;, and then &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L38" target="_blank"&gt;turn the provided IPs into connectable
names&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Connection&lt;/h2&gt;

&lt;p&gt;My favorite part of peerage, by far, is how simple the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/server.ex" target="_blank"&gt;server&lt;/a&gt;
is that actually connects nodes together. The polling code triggers the &lt;code&gt;discover&lt;/code&gt; method
and reschedules for some interval in the future. If you haven&amp;rsquo;t seen it before, the
&lt;code&gt;Process.send_after&lt;/code&gt; line here is very common for creating gen servers which do some
regular interval&amp;rsquo;d work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def handle_info(:poll, state) do
  discover()
  Process.send_after(self(), :poll, interval() * 1000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the real simplicity comes out with node connections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp discover do
  poll()
  |&amp;gt; only_fresh_node_names
  |&amp;gt; Enum.map(&amp;amp;([&amp;amp;1, Node.connect(&amp;amp;1)]))
  |&amp;gt; log_results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nodes are polled using the mechanisms we saw previously, then compared against currently
connected nodes. &lt;code&gt;Node.connect&lt;/code&gt; is then called on the symbol provided by the providers, and attempted
to connect to. When a Node connects, erlang handles all of the security and heartbeat, as
laid out in the &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;previous post&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;This simple and elegant library has been a cornerstone for me connecting nodes together in
kubernetes. It is great to see that there is no hacky implementations under the covers. It is
simply easy to follow and debug Elixir code, falling back on known erlang libraries.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 6th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Elixir Node Networking Basics</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html"/>
    <id>https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html</id>
    <published>2018-02-05T21:08:00-05:00</published>
    <updated>2018-02-06T00:17:22-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;One of my favorite points in Elixir, some form of magic perhaps, is how simple
distributed networking can be. The language itself seems to make establishing
networked nodes and sending messages a pain-free exercise. While breaking down
networking techniques is more than a single post, I am going to look into some of
the basics of networking in Elixir. Specifically, what happens when we connect
nodes together?&lt;/p&gt;

&lt;h2&gt;Nodes in Elixir&lt;/h2&gt;

&lt;p&gt;In Elixir, a &lt;code&gt;Node&lt;/code&gt; could be defined as a single running instance. There can be
multiple nodes running on a single machine. Let&amp;rsquo;s use this to take a look at some
basics of node communication, before diving into what is going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
iex --name test@127.0.0.1

# In shell 2
iex --name test2@127.0.0.1

# In shell 1
Node.self() # :&amp;quot;test@127.0.0.1&amp;quot;
Node.list() # []
Node.connect(:&amp;quot;test2@127.0.0.1&amp;quot;) # true
Node.list() # [:&amp;quot;test2@127.0.0.1&amp;quot;]

# In shell 2
Node.list() # [:&amp;quot;test@127.0.0.1&amp;quot;]

# Leave open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above interactive example, it&amp;rsquo;s possible to see that 2 nodes are initially
started, with a particular name of &lt;code&gt;test@127.0.0.1&lt;/code&gt; or test2. These nodes start as
disconnected, but can be manually connected. Once connected, both nodes are aware of the
other node&amp;rsquo;s existence.&lt;/p&gt;

&lt;p&gt;Finally, we can test out sending a message in the above processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
Node.spawn(:&amp;quot;test2@127.0.0.1&amp;quot;, fn -&amp;gt; IO.inspect(Node.self()) end)
#PID&amp;lt;13084.113.0&amp;gt;
:&amp;quot;test2@127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, a function is set to be executed on &lt;code&gt;:&amp;quot;test2@127.0.01&amp;quot;&lt;/code&gt;. We can see
that the result of the execution is a remote pid (doesn&amp;rsquo;t start with 0) as well the output
containing the node&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;The Node module contains lots of interesting tidbits that are actually implemented pretty
thin on top of erlang modules. This post won&amp;rsquo;t go into the ins and outs of node communication,
although it&amp;rsquo;s suffice to say that communication is generally done in better ways than
spawning functions between the nodes.&lt;/p&gt;

&lt;h2&gt;Diving into a connection&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/node.ex#L150" target="_blank"&gt;Node.connect&lt;/a&gt; provides
a really simple 1-liner over &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;. Let&amp;rsquo;s dig into this function and
what some ramifications of using it are.&lt;/p&gt;

&lt;p&gt;Deep inside of the erlang OTP libraries, we start to see some interesting code in connection.
Specifically, there is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L313" target="_blank"&gt;code&lt;/a&gt;
to handle automatic &amp;ldquo;magical&amp;rdquo; connection between nodes, vs more explicit connection dependencies.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L342" target="_blank"&gt;Digging even further&lt;/a&gt;,
we discover that the &lt;code&gt;net_kernel&lt;/code&gt; symbol is actually a process on the system. Running &lt;code&gt;Process.whereis(:net_kernel)&lt;/code&gt;
will return the pid of this net_kernel process.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L422" target="_blank"&gt;The first time that a Node is connected to&lt;/a&gt;,
that connection is not present in the ets lookup table. This leads to setup being called and
initializing that connection.&lt;/p&gt;

&lt;p&gt;By digging into &lt;code&gt;Process.whereis(:net_kernel) |&amp;gt; :sys.get_state()&lt;/code&gt;, it&amp;rsquo;s possible to see that
there is a structure like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:listen, #Port&amp;lt;0.609&amp;gt;, #PID&amp;lt;0.49.0&amp;gt;,
    {:net_address, {{0, 0, 0, 0}, 56479}, &amp;#39;Steves-MBP&amp;#39;, :tcp, :inet},
    :inet_tcp_dist}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This state is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L113" target="_blank"&gt;documented&lt;/a&gt;
and helps to let us trace the module that will actually connect our nodes together. Finally, we
are able to track down the &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/inet_tcp_dist.erl#L296" target="_blank"&gt;setup code&lt;/a&gt;
that is creating the TCP socket between the nodes.&lt;/p&gt;

&lt;p&gt;One small caveat of connecting to nodes is that &amp;ldquo;cookies&amp;rdquo; have to match up. This is
essentially an atom that is initialized on boot and read from &lt;code&gt;~/.erlang.cookie&lt;/code&gt;. Finding
this was pretty challenging in erlang, but I traced it back to
&lt;a href="https://github.com/erlang/otp/blob/d99803e7625e474dee40f0dfebf2b8092add0336/lib/kernel/src/dist_util.erl#L216" target="_blank"&gt;dist_util&lt;/a&gt;
module. The code above (even if you can&amp;rsquo;t read erlang) is doing some interesting challenge/reply
protocol to ensure that the nodes are allowed to talk to each other.&lt;/p&gt;

&lt;h2&gt;After the connection&lt;/h2&gt;

&lt;p&gt;Of course, connecting via TCP here is just the beginning. There is significantly more
at play, cookies to authenticate nodes and heartbeats to ensure connectivity between nodes
for starters. The &lt;a href="http://learnyousomeerlang.com/distribunomicon" target="_blank"&gt;distributed erlang guide&lt;/a&gt; from
learnyousomeerlang.com goes over some of these concepts in detail. I&amp;rsquo;ll be tackling them
in a future post as well.&lt;/p&gt;

&lt;h2&gt;Addendum&lt;/h2&gt;

&lt;p&gt;It was asked in the Elixir slack group if it&amp;rsquo;s possible to customize the distribution mechanism
from TCP/IP to something else. It is! It&amp;rsquo;s fairly involved C code, but there is &lt;a href="http://erlang.org/doc/apps/erts/alt_dist.html" target="_blank"&gt;an example&lt;/a&gt;
walking through a OS socket level distribution.&lt;/p&gt;

&lt;p&gt;In addition, some other drivers are provided out of the box, such as a
&lt;a href="http://erlang.org/doc/apps/ssl/ssl_distribution.html" target="_blank"&gt;SSL driver&lt;/a&gt; for communicating
over SSL.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;I don&amp;rsquo;t really read erlang code, so this post was very interesting today. However, a lot
of great things can be learned from digging into the erlang code and module documentation
and not relying solely on Elixir docs. For instance, the documentation for node networking
brings up great points around security and TLS node communication. Dive into the docs and
see what you go from there; it might be useful one day when there&amp;rsquo;s a problem that you
just can&amp;rsquo;t figure out.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 5th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Sourcing Libraries from Private Github</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html"/>
    <id>https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html</id>
    <published>2018-02-04T19:57:00-05:00</published>
    <updated>2018-02-04T20:29:42-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Hex is currently working on &lt;a href="https://hex.pm/docs/private" target="_blank"&gt;private organizations&lt;/a&gt; which
are in beta. Until the full details of those are public and available, you may find
yourself needing to source Elixir libraries privately. You may also just desire a quick
fix and not setting up private packages. Enter git sourced packages.&lt;/p&gt;

&lt;h2&gt;Mix and Git&lt;/h2&gt;

&lt;p&gt;At the simplest form, you can think of git sourced dependencies as a clone of the provided
repo using system git. In fact, the implementation is
a &lt;a href="https://github.com/elixir-lang/elixir/blob/f77cc2657cf981fdf819915f1ee15e69c3cd91ad/lib/mix/lib/mix/scm/git.ex#L250" target="_blank"&gt;shell out to git&lt;/a&gt;.
This means any repo which a system can access will be accessible via git, including
repos which are locked behind private access.&lt;/p&gt;

&lt;p&gt;I have seen tags work as a good way to mark the versions in the git repo. The form looks
something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: &amp;quot;v1.0.0&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above mix.exs entry will fetch the mix package named &lt;code&gt;:my_dependency_name&lt;/code&gt; from git@github.com:Organization/repo.git,
commit tagged v1.0.0. &lt;a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank"&gt;Github SSH&lt;/a&gt; access
is used due to the repo being &lt;code&gt;git@github.com&lt;/code&gt; format.&lt;/p&gt;

&lt;h2&gt;Trickery with Docker and CI&lt;/h2&gt;

&lt;p&gt;This all works well locally. In fact, just following the standard tutorial will lead to a working
private dependency, locally. Things get a bit trickier when something like Docker or a build
server is used to fetch your dependency. In this situation, the SSH key of each system would need
to be included on Github. Another difficulty is that Docker containers have to have SSH keys added
to them, they don&amp;rsquo;t come with them standard. All of this leads to another possible solution:
accessing Github via API keys.&lt;/p&gt;

&lt;h2&gt;API Key Setup&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/blog/1509-personal-api-tokens" target="_blank"&gt;Github personal access tokens&lt;/a&gt; can be used
to access certain parts of Github, such as repository access. In order to use one with mix,
just switch out the git url from &lt;code&gt;git@github.com:Organization/repo.git&lt;/code&gt; to
&lt;code&gt;https://#{access_token}@github.com/Organization/repo&lt;/code&gt;. With this solution, any access token
which has read access to the repo will serve as the access into Git.&lt;/p&gt;

&lt;p&gt;There does exist a drawback with this solution, the access token would need to be provided to
every user of the application. This is non-desirable as the access token should really be kept
secret, even to the point of being encrypted docker arguments. With a small tweak, it is possible to
achieve the best of both worlds, SSH locally but access tokens for Docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp deps do
  [
    {:phoenix, &amp;quot;~&amp;gt; 1.3.0&amp;quot;},
  ] ++ private_deps(System.get_env(&amp;quot;MIX_GITHUB_ACCESS_TOKEN&amp;quot;))
end

@my_dependency_version &amp;quot;v1.0.0&amp;quot;

defp private_deps(nil) do
  [
    {:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: @my_dependency_version},
  ]
end

defp private_deps(access_token) do
  [
    {:my_dependency_name, git: &amp;quot;https://#{access_token}@github.com/Organization/repo&amp;quot;, tag: @my_dependency_version},
  ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will append the private dependencies into the deps list, but do so with
either SSH or access token access. Dependency versions should always be constant, so
it is pulled into an attribute.&lt;/p&gt;

&lt;p&gt;One caveat with this approach is that each mix invocation must contain the ENV, not
just &lt;code&gt;deps.get&lt;/code&gt;. This is due to the mix.lock being checked when mix runs, and the
correct dependencies are pulled each time through the above code path.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;With the presented approach, there should be little trouble getting private repos
both locally and in CI, without compromise on security of your keys. If the straight access
token route is taken, take extra care regarding the permissions of the account behind
the key.&lt;/p&gt;

&lt;p&gt;Thanks for reading the fourth post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate the posts to get more and more technical as the time goes on!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Bringing Elixir to Others - New Language vs. New Paradigm</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html"/>
    <id>https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html</id>
    <published>2018-02-03T14:46:00-05:00</published>
    <updated>2018-02-03T15:10:05-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;ll be giving a talk next week about taking Elixir into production. While there are
technical challenges to doing so, I must also consider the human-based challenges that will be faced. For
example, most team members will be learning a new language when they are introduced to Elixir.
If they have been doing object-oriented coding, will a functional coding paradigm get them stuck?
Will OTP and the paradigm of a process based application cause confusion?&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t necessarily present answers to some of these questions today, but rather bring up
questions that I&amp;rsquo;ve heard and alternative ways of thinking about the answers.&lt;/p&gt;

&lt;h2&gt;Functional Programming and Elixir Itself&lt;/h2&gt;

&lt;p&gt;Before all of the fun and excitement of making a real Elixir application comes the challenge of
learning the Elixir language. Most people that ask me about learning Elixir focus on what
types of courses they can pay for online to get into the language. While I&amp;rsquo;m sure that some
people are going to benefit from these courses enormously, it&amp;rsquo;s never the first place I&amp;rsquo;d send
someone. Instead, I recommend the &lt;a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank"&gt;Elixir Getting Started Guide&lt;/a&gt;.
This guide is put together by the official Elixir team and covers an introduction to the language itself.&lt;/p&gt;

&lt;p&gt;As other members of the organization dive into the concepts of Elixir, questions will
be raised about what functional programming is, what does immutability mean, and what is &amp;ldquo;all of this&amp;rdquo; in practice?
Even further questioning might ask &amp;ldquo;what makes the functional paradigm good?&amp;rdquo; Other team members will rely
on the Elixir champion to answer these questions, so be prepared for them to pop up once people start learning.
I read something in a reddit comment today that I really liked on this topic: the value of the data
doesn&amp;rsquo;t change in Elixir, but rather the variables point to new pieces of data. I thought that was a
very straight-forward way of looking at the functional programming model that Elixir brings.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I prep anyone that is going through the getting started guide that it will take probably 2-4 times
to really understand Elixir to the point of being comfortable when reading other people&amp;rsquo;s code. Having
a real world project to read and play around with can lower this learning curve.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;OTP&lt;/h2&gt;

&lt;p&gt;OTP is a cornerstone of writing Elixir applications. There&amp;rsquo;s lot of things about the topic already, but
I had an interesting observation the other day about OTP and how it relates to bringing Elixir to the
rest of an organization:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The majority of business applications could be built with all OTP hidden away by libraries, to the point
of developers not needing to know the details of OTP.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While I think that using OTP can help bring about advantages in an application, especially in a distributed
environment, it is not really necessary. For example, a developer could start a new application today and
serve the HTTP layer with Phoenix. They could then spin up a queue system like ExQ in order to process
background jobs. Finally, they can connect websockets for read/write access to the API. All of this can happen
without ever typing &lt;code&gt;GenServer&lt;/code&gt; in code and create an application which satisfies the business.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t necessarily best practice, but I believe that it&amp;rsquo;s okay to sometimes put aside best practice
in order to achieve an initial velocity. Once the team is rolling, the OTP concepts will come out of the
woodwork and start to make sense, hopefully faster than they would in isolation.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Regardless of how you approach bringing Elixir to the people on your team, realize that you must be a
champion for the education and empowerment of the team. Look for interesting ways to answer questions that
people have and remove the roadblocks that pop-up as quick as you can.&lt;/p&gt;

&lt;p&gt;Thanks for reading the third post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
</feed>

<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen Bussey's Software Engineering Blog</title>
  <id>https://stephenbussey.com</id>
  <link href="https://stephenbussey.com"/>
  <link href="https://stephenbussey.com/feed.xml" rel="self"/>
  <updated>2018-02-10T12:20:00-05:00</updated>
  <author>
    <name>Stephen Bussey</name>
  </author>
  <entry>
    <title>28 days - Phoenix websocket dive</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/10/phoenix-websocket-dive.html"/>
    <id>https://stephenbussey.com/2018/02/10/phoenix-websocket-dive.html</id>
    <published>2018-02-10T12:20:00-05:00</published>
    <updated>2018-02-11T00:00:05-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I, and seemingly most people that use them, have a positive view towards Phoenix
websockets. They are simple to use, scalable, and are stable in production. I have
some neat content that I want to go over with websockets, but it will be better
to do a deep dive into how they work first. In particular, the process structure
and how they scale.&lt;/p&gt;

&lt;p&gt;I have prepared a demo repository that implements a few different websocket concepts.
The goal of this demo is to reinforce / provide material for this post. You can
find the repo on &lt;a href="https://github.com/sb8244/websocket-demo/tree/66b7933157be16b4e6d03ab08e21fc9b9841882d" target="_blank"&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The beginning section will start with basics of the websocket, leading into
how the websocket internals work.&lt;/p&gt;

&lt;h2&gt;Websocket Tests&lt;/h2&gt;

&lt;p&gt;Before going into the code that powers the websocket, let&amp;rsquo;s dive into the code that &lt;em&gt;tests&lt;/em&gt;
the websocket. &lt;a href="https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html" target="_blank"&gt;Phoenix.ChannelTest&lt;/a&gt; provides
some helpers that make testing the socket simple. There is some complex setup that goes into the socket,
but these helpers reduce the complexity.&lt;/p&gt;

&lt;p&gt;The first test that I like to start with is a test for &lt;a href="https://github.com/sb8244/websocket-demo/blob/66b7933157be16b4e6d03ab08e21fc9b9841882d/test/websocket_demo_web/channels/demo_channel_test.exs#L10" target="_blank"&gt;joining a channel&lt;/a&gt;.
A channel is an abstraction over the websocket to allow for the actual bi-directional communication. When
we &amp;ldquo;communicate&amp;rdquo; to a socket, we&amp;rsquo;re actually communicating to the channel. It is good practice
to test that the socket is authenticated to join a particular channel, but this demo does not
use any authorization.&lt;/p&gt;

&lt;p&gt;One of the very core behaviors of a websocket is responding to a request from the client.
This is &lt;a href="https://github.com/sb8244/websocket-demo/blob/66b7933157be16b4e6d03ab08e21fc9b9841882d/test/websocket_demo_web/channels/demo_channel_test.exs#L45" target="_blank"&gt;tested&lt;/a&gt;
using &lt;code&gt;assert_reply&lt;/code&gt;, which ensures that the particular push to the websocket is responded to.
We will dig into what &amp;ldquo;responding to a push&amp;rdquo; means, below.&lt;/p&gt;

&lt;p&gt;One test that I struggled a bit with was &lt;a href="https://github.com/sb8244/websocket-demo/blob/66b7933157be16b4e6d03ab08e21fc9b9841882d/test/websocket_demo_web/channels/demo_channel_test.exs#L26" target="_blank"&gt;testing that the async timer was enqueued for 5 seconds&lt;/a&gt;.
I started this test by making the test wait for 5s, which was really not a good strategy. What
I ended with was keep the timer reference in a state variable, and reading that from the test. It
might not be great to reach into the internals of a structure in a test, but the alternative is
waiting a very long time in the test suite. I ended up being okay with this tradeoff for the
delayed push test, as I could easily make it run in less time by changing from 300ms to
something else.&lt;/p&gt;

&lt;p&gt;You can find the implementation that satisfies these tests &lt;a href="https://github.com/sb8244/websocket-demo/blob/66b7933157be16b4e6d03ab08e21fc9b9841882d/lib/websocket_demo_web/channels/demo_channel.ex" target="_blank"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Behind the scenes, what is a websocket?&lt;/h2&gt;

&lt;p&gt;The real purpose of this post is to explore what a websocket is. Specifically, what
is happening when connection, pushes, and responses happen. Let&amp;rsquo;s start by looking at
the process structure for when a websocket is created. I will do this by opening
&lt;code&gt;:observer.start&lt;/code&gt; and looking at the difference when a socket is created.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/websocket-dive/one-socket.png" alt="one socket appears in the process tree" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;The rightmost process is the websocket process&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Above, the pid &lt;0.369.0&gt; is the websocket process. This is possible to visualize by
clicking on that process and viewing the state. It shows the websocket internal state.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/websocket-dive/369-socket.png" alt="pid 369 appears clearly as the socket" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;It is possible to view the Socket struct in the state information&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;One interesting thing about this pid is that it appears in the state itself, as the
&lt;code&gt;channel_pid&lt;/code&gt; key of the Elixir.Phoenix.Socket struct. As if seeing the process in
observer is not enough, this gives the proof that the channel is a process.&lt;/p&gt;

&lt;p&gt;Also in the process state is a second pid called &lt;code&gt;transport_pid&lt;/code&gt;. This process is where
the actual websocket protocol occurs.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/websocket-dive/transport-process.png" alt="the transport process information" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;The transport process is the parent of the channel process&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Internally, there is a &lt;a href="https://github.com/phoenixframework/phoenix/blob/master/lib/phoenix/channel/server.ex#L186" target="_blank"&gt;&lt;code&gt;Phoenix.Channel.Server&lt;/code&gt;&lt;/a&gt;
GenServer which wraps around the behavior of the defined channel. I initially thought
that saying &lt;code&gt;use Phoenix.Channel&lt;/code&gt; would cause the channel to become a GenServer, but
that is proved false by seeing that the Phoenix.Channel.Server implementation sets
&lt;code&gt;channel_pid: self()&lt;/code&gt;. I won&amp;rsquo;t dig into this server implementation today.&lt;/p&gt;

&lt;p&gt;I also won&amp;rsquo;t dig into the cowboy code, but we can see that the actual websocket
implementation happens at the cowboy level via &lt;a href="https://ninenines.eu/docs/en/cowboy/2.0/manual/cowboy_websocket/" target="_blank"&gt;cowboy_websocket&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, the PubSub.Local0 process is monitoring the channel process. I am going to leave
this implementation up for another blog post, or as an exercise for you.&lt;/p&gt;

&lt;h2&gt;Websocket messages&lt;/h2&gt;

&lt;p&gt;Google Chrome provides functionality to view what a websocket is doing. This can be
accessed by finding the websocket in the Network tab. The websocket request has a
&amp;ldquo;frames&amp;rdquo; inner section. When you view this, you may need to drag down the &amp;ldquo;select a frame&amp;rdquo;
content to view the frames themselves.&lt;/p&gt;

&lt;div style="text-align: center"&gt;
  &lt;img src="/images/websocket-dive/frontend-messages.png" alt="frontend message frames" /&gt;
  &lt;div&gt;
    &lt;small&gt;
      &lt;i&gt;The in/out of the client websocket&lt;/i&gt;
    &lt;/small&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;When a message is pushed from the JS client to the backend, it sends the request in the format
&lt;code&gt;[join_ref, message_ref, topic, message, payload]&lt;/code&gt;. The join&lt;em&gt;ref and message&lt;/em&gt;ref are actually
really important. These are used in the response (same format as the request) to allow calling
back to the right function. Phoenix provides the &lt;code&gt;reply&lt;/code&gt; function to reply to a &lt;code&gt;socket_ref&lt;/code&gt;.
The demo uses this to &lt;a href="https://github.com/sb8244/websocket-demo/blob/66b7933157be16b4e6d03ab08e21fc9b9841882d/lib/websocket_demo_web/channels/demo_channel.ex#L26" target="_blank"&gt;reply asynchronously&lt;/a&gt;
to requests. Asynchronous replies must happen within the channel timeout period (10s default). A
timeout event will trigger if it is not in that timeframe. It is possible to override this timeframe
to be whatever you need for your use case.&lt;/p&gt;

&lt;p&gt;The two refs can be null, as seen for the tick message. This will cause it to
be a global message handler rather than a local one.&lt;/p&gt;

&lt;h2&gt;What are the benefits of a channel / transport process?&lt;/h2&gt;

&lt;p&gt;The process structure of Phoenix websockets is one of the things that helps make it
fault tolerant. Let&amp;rsquo;s say that something goes wrong with the channel process and causes
it to crash. The process will be started back up from the supervisor, causing the
&lt;code&gt;join&lt;/code&gt; function to be called (triggering any join callbacks on the client). However,
the channel crash does not cause the client to see any fault in the socket it has.&lt;/p&gt;

&lt;p&gt;If the transport process crashes, the client sees a disconnection and will try to reconnect.
The channel process also restarts, because it is a child of the transport process. In this
scenario, the system ends in a stable operating state.&lt;/p&gt;

&lt;p&gt;A benefit of the channel process is that the process can be controlled like any other process.
It can handle messages via a &lt;code&gt;handle_info&lt;/code&gt; callback, which the demo uses to create a
tick every 5 seconds. It can also store arbitrary state (best practice is the assigns
map) which can be used to like any other GenServer state.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;I have a few different things that are more advanced than an intro to websocket post. My
current ideas are how to debounce a websocket push (push once every X seconds) and also
what happens to setup the websocket requests.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 10th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am looking for new topics to write about, so please reach out if there&amp;rsquo;s anything you
really want to see!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days - How I learned Elixir</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/10/how-i-learned-elixir.html"/>
    <id>https://stephenbussey.com/2018/02/10/how-i-learned-elixir.html</id>
    <published>2018-02-10T00:15:00-05:00</published>
    <updated>2018-02-10T00:43:16-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I recently had a request to consider more beginner focused content in this 28 days
series. This goes really well with one of my goals, which is to get more people
excited about Elixir and wanting to try it out. Helping out beginners to the
language is a great way to achieve this goal. I have been reflecting on my
learning process and considering what worked well and didn&amp;rsquo;t work so well. I do
recognize that everyone learns differently and values different goals. This is my perspective,
but another person&amp;rsquo;s might be very different.&lt;/p&gt;

&lt;p&gt;When I first started Elixir, I had extensive programming experience, but no real
experiences with functional programming, nor any BEAM languages. Thus, my first goal
became just to understand the syntax of the language and learn how the basic constructs
of the language work (think variables, function definition / usage, etc.) I found that
the best place for this is in the Elixir documentation itself, namely the
&lt;a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank"&gt;getting started&lt;/a&gt; guide.&lt;/p&gt;

&lt;h2&gt;Getting Started Guide&lt;/h2&gt;

&lt;p&gt;This guide is extensive, which is great for working out most of the finer details of
the language itself. It breaks down into functional language tutorials, followed by
tutorials of mix/OTP.&lt;/p&gt;

&lt;p&gt;I found the initial exploration of these guides fairly straightforward. Everything would click
well for me, and examples / changes to them work as expected. This was all great and
felt like an achievement. However, I wasn&amp;rsquo;t really understanding the content. It took me
about 4 times through the series before I could actually write any of it from memory. In
particular, the OTP concepts were much more difficult to understand than I would like
to admit. I had significant trouble in that area.&lt;/p&gt;

&lt;p&gt;Transitioning out of that, I went directly into some real example projects.&lt;/p&gt;

&lt;h2&gt;Finding a project&lt;/h2&gt;

&lt;p&gt;I knew that the tutorial wasn&amp;rsquo;t fully cutting it for me. I ended up deciding to try to
write a project that I knew was over my head. I ended up deciding to make a local SMTP trap.
It would need to listen on a port and then communicate over a very basic SMTP protocol.
This project was great for me for 2 reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The end goal was significantly over my head from when I started&lt;/li&gt;
&lt;li&gt;The content was beyond &amp;ldquo;normal&amp;rdquo; applications that I write, this made it interesting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Even though I haven&amp;rsquo;t touched the project in a while, I do still keep it on
&lt;a href="https://github.com/sb8244/elixir-smtp" target="_blank"&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Throughout this time, I had found people to bounce problems / ideas off of for how I
would implement things. I believe that finding some support network is crucial for
seeing these complex problems through.&lt;/p&gt;

&lt;h2&gt;Educating at work&lt;/h2&gt;

&lt;p&gt;The piece that has had a recent big impact on me and allowed me to solidify my learnings
even further is switching to the perspective of teacher. At work, people have been
adopting Elixir and gaining interest. As new people learn the language, they will
inevitably need help with it. I find that teaching others is usually the most important
thing for me. This is one where what you put in dictates what you get out.&lt;/p&gt;

&lt;h2&gt;Things I would not do differently&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t think that I would have looked at paid content to learn the langauge. The tutorials
are so extensive and written by the same people that made the language that it just seems
like the right choice to use those tutorials.&lt;/p&gt;

&lt;p&gt;In addition, I would not hide any early work from the public or my peers. It
would be okay for others to know what I was working on it even if it wasn&amp;rsquo;t ready yet, as
it might encourage them to start up as well.&lt;/p&gt;

&lt;h2&gt;Things I would do differently&lt;/h2&gt;

&lt;p&gt;On the idea of educating others and doing self-learning through the Elixir tutorial,
I will say that working through the tutorials with another person would have been a
huge benefit. That learning/education cycle would have been established much earlier and
allowed for the faster growth. This is obviously dependent on finding someone who is
interested in learning Elixir.&lt;/p&gt;

&lt;p&gt;I would have jumped into projects at work a bit sooner to understand even more. This
includes both writing Elixir code myself and reading other code that other&amp;rsquo;s produced
with significant attention.&lt;/p&gt;

&lt;p&gt;I would pick a small codebase from a language that I know well (Ruby) and convert it
into Elixir. I ended up doing this for a work library recently, and that learning was
immense. Being a subject matter expert in a certain area means that the act of applying
that knowledge into another language doesn&amp;rsquo;t involve getting lucky with the project
selection.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;No matter who the person is or what their goals are, I would always have one piece
of advice for someone going down a similar path: &amp;ldquo;just start&amp;rdquo;. Start the process
and figure out a way to make progress, overcoming challenges that inevitably rise.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 9th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am looking for new topics to write about, so please reach out if there&amp;rsquo;s anything you
really want to see!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Demo - Single process in a distributed system</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/09/demo-explanation-single-process-in-a-distributed-system.html"/>
    <id>https://stephenbussey.com/2018/02/09/demo-explanation-single-process-in-a-distributed-system.html</id>
    <published>2018-02-08T22:20:00-05:00</published>
    <updated>2018-02-08T23:37:33-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;m really excited about this post, I&amp;rsquo;ve been thinking about what the demo will
look like for several days, but it turned out differently than I had in my head.
I&amp;rsquo;m writing this from 35k feet on my way to vacation; there&amp;rsquo;s nothing better than
being on a plane to hash out technical problems that have been put off. It would
be great if the wifi worked though&amp;hellip;&lt;/p&gt;

&lt;p&gt;Today&amp;rsquo;s post is going to be a demo + walkthrough of creating a singular process
chokepoint in a distributed system. That might not be the best way to explain it, but
I&amp;rsquo;m also struggling to find a better explanation. The end goal is that in a cluster
of 3 nodes, I can say &amp;ldquo;request id 1&amp;rdquo; and have that go to node 1 every time. I can say
&amp;ldquo;request id 3&amp;rdquo; and have that go to node 3.&lt;/p&gt;

&lt;h2&gt;Code / Demo&lt;/h2&gt;

&lt;p&gt;The code is found at &lt;a href="https://www.github.com/sb8244/distributed_process_demo" target="_blank"&gt;https://www.github.com/sb8244/distributed_process_demo&lt;/a&gt;.
The repo has instructions for the actual demo and how it should be run.&lt;/p&gt;

&lt;p&gt;This code is in the intermediate category, probably. However, it&amp;rsquo;s short and the
tools used are core for building Elixir apps. Don&amp;rsquo;t be shy to dig in and break it
locally to really learn what&amp;rsquo;s going on!&lt;/p&gt;

&lt;h2&gt;How it works&lt;/h2&gt;

&lt;p&gt;Elixir has the ability to connect to other nodes that are accessible on the network. We
can use this to spawn several local nodes that simulate a networked environment. The
&lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process.ex#L4" target="_blank"&gt;&lt;code&gt;DistributedProcess.connect()&lt;/code&gt;&lt;/a&gt;
function iterates on up to 5 known node names and connects to them. This is a quick hack to get them connected.&lt;/p&gt;

&lt;p&gt;The application creates two different top level supervisors, a &lt;code&gt;Registry&lt;/code&gt; which allows
unique storage of processes (unique by ID here) and a &lt;code&gt;DistributedProcess.Supervisor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process/supervisor.ex" target="_blank"&gt;&lt;code&gt;DistributedProcess.Supervisor&lt;/code&gt;&lt;/a&gt;
does the majority of the work for distributing our
process across the cluster. It accepts an &lt;code&gt;id&lt;/code&gt; into the &lt;code&gt;get_worker/1&lt;/code&gt; function, and
uses a modulo operator on the number of nodes to determine which node will be the lucky
receiver of this request. The size of a node is fairly consistent in practice, so this
seems acceptable for starters.&lt;/p&gt;

&lt;p&gt;When the right node is chosen, the &lt;code&gt;DynamicSupervisor.start_child&lt;/code&gt; call creates an instance
of a &lt;code&gt;DistributedProcess.Worker&lt;/code&gt; on the local or remote chosen node. This Worker is setup to
be unique based on the ID. This is really helpful as it allows future calls to the same ID
to return the same process.&lt;/p&gt;

&lt;p&gt;Once a local or remote pid is returned from the DynamicSupervisor, that pid has a &lt;code&gt;call&lt;/code&gt; request
execute against it. &lt;code&gt;call&lt;/code&gt; will return an answer synchronously, which is great for the purposes
of this demo.&lt;/p&gt;

&lt;p&gt;In the &lt;a href="https://github.com/sb8244/distributed_process_demo/blob/master/lib/distributed_process/worker.ex" target="_blank"&gt;&lt;code&gt;DistributedProcess.Worker&lt;/code&gt;&lt;/a&gt;,
the first thing is does is actually tell itself to be destroyed
in 5 seconds. This is to make the demo interesting, but also simulates the use case of a short
lived cache.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;handle_call(:request)&lt;/code&gt; function in the worker does 2 different things, for 2 different
function heads. The first is if there is a value in the local state. Then it is simply
returned as is. The second is if there is no value in the local state. A random 1-1000
integer is selected and placed in the state, along with the node name. This allows us to see
that the data is in fact changing every 5 seconds, and where it came from.&lt;/p&gt;

&lt;p&gt;All of this is packaged up into 2 top level functions that are called: &lt;code&gt;DistributedProcess.connect()&lt;/code&gt;
and &lt;code&gt;DistributedProcess.request(id)&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Use Case&lt;/h2&gt;

&lt;p&gt;It may be desirable to have a single choke point across a cluster to handle a single
type of request. For instance, maybe a certain tenant should only execute on a single
server. This ensures that the requests for that tenant are serial (non-parallel).&lt;/p&gt;

&lt;p&gt;My use case is to cache requests to a certain resource/id pair for 30-60 seconds. I want
to make a single request, then return that value for the lifetime of it. I do not
want to introduce a DB layer just for this caching, as maintaining that is prone to
easier logic errors around cache expiration and checking.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m most excited about how this code doesn&amp;rsquo;t really feel remote. It can run on a
local system just as well as in a clustered system, and it scales with cluster size
with no additional work. That is pretty fun!&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know how I would easily test this code. Not having internet led me to not
test this code today. However, I will probably look into how I can test it and write
about that in the future. I have had several requests for testing posts, especially
if they involve complex setups.&lt;/p&gt;

&lt;p&gt;I do not know, yet, how I would handle a situation of fetching an array of ids. I would
want the cache to be distributed, but there is a challenge in not having the same id
set each time. This sort of breaks the technique, but it doesn&amp;rsquo;t mean it&amp;rsquo;s not valuable
for single / deterministic ids.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Thanks to my co-worker Ben for bouncing this idea around at SalesLoft. We haven&amp;rsquo;t placed
the technique in production yet, but him and I were both really excited to talk about it.
I&amp;rsquo;m curious to see how he would approach this type of problem, as I know he had more
elegant solutions in mind.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 8th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am looking for new topics to write about, so please reach out if there&amp;rsquo;s anything you
really want to see!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - The Beauty of Macros</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/08/the-beauty-of-macros.html"/>
    <id>https://stephenbussey.com/2018/02/08/the-beauty-of-macros.html</id>
    <published>2018-02-07T22:31:00-05:00</published>
    <updated>2018-02-07T22:48:55-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;m aiming for a shorter post today, as I presented a 50 minute talk about &amp;ldquo;Elixir in Production&amp;rdquo;
at the Atlanta Elixir Meetup tonight. I&amp;rsquo;m proud of how the talk turned out, but I&amp;rsquo;m
also looking forward to hearing what content will make it better, and submitting it
to conferences.&lt;/p&gt;

&lt;p&gt;For the end of the first week (7th day) of Elixir writing, I wanted to break down a
small chunk of code that I recently wrote that utilizes macros. In particular,
there&amp;rsquo;s a cool property of macros that I want to explain. Let&amp;rsquo;s just go into the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule SalesloftApi.Phoenix.Router do
  defmacro setup({:__aliases__, _ctx, module_path}, controller) do
    router_module = Module.concat(module_path)

    router_module.min_api_version()..router_module.current_api_version()
    |&amp;gt; Enum.flat_map(fn api_version -&amp;gt;
      router_module.routes()
      |&amp;gt; Map.values()
      |&amp;gt; Enum.map(fn route = %{http_verb: verb} -&amp;gt;
        path = SalesloftApi.Route.path(route)

        quote do
          scope &amp;quot;/v#{unquote(api_version)}&amp;quot; do
            unquote(verb)(unquote(path), unquote(controller), :execute, assigns: %{route: unquote(Macro.escape(route))})
          end
        end
      end)
    end)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For context, this code is an adapter to convert between a router module and phoenix routes.
We are doing this in order to provide our API at a level outside of just HTTP (like websockets or
console) and to ensure that we can control how the API is documented at a very native
level. I previous &lt;a href="/2017/09/04/get-your-rails-out-of-my-ruby-http.html" target="_blank"&gt;wrote&lt;/a&gt; about a similar
concept in Ruby.&lt;/p&gt;

&lt;p&gt;This code is a macro which accepts a module and a controller module into it. It&amp;rsquo;s intended to be
called from a Phoenix.Router module.&lt;/p&gt;

&lt;p&gt;The code follows this simplified flow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Iterate over available versions of the API (2-&amp;gt;2 currently)&lt;/li&gt;
&lt;li&gt;Iterate over the available routes&lt;/li&gt;
&lt;li&gt;Generate some Phoenix.Router compatible code like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;scope &amp;quot;/v2&amp;quot; do
  get(&amp;quot;/widgets&amp;quot;, FrontController, :execute, assigns: %{route: route})
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Provide the generated code as the macro&amp;rsquo;s return.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is my &lt;strong&gt;favorite&lt;/strong&gt; part of this code: it doesn&amp;rsquo;t know what phoenix is. This project
does not take phoenix in as a dependency&amp;hellip;you don&amp;rsquo;t need to use phoenix to use this module.
What needs to happen is that there must be code that supports &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt;/friends in
the module that calls this. It just happens to be phoenix.&lt;/p&gt;

&lt;p&gt;This captures the flexibility of Elixir very concisely. The code that a macro generates is
&amp;ldquo;placed into&amp;rdquo; the call site, and the original library doesn&amp;rsquo;t execute that code.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;If you do decide to learn what macros are about, I can&amp;rsquo;t recommend
&lt;a href="https://pragprog.com/book/cmelixir/metaprogramming-elixir" target="_blank"&gt;Metaprogramming Elixir&lt;/a&gt; enough.
I found the book to be excellent at highlighting how macros are really used in the
Elixir code that I use daily.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 7th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
am leaving for vacation tomorrow. I&amp;rsquo;m excited for the time to reflect on interesting topics and
to have more time in the evening to write about them&amp;hellip;hopefully. Cheers!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Peerage Deep Dive</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/07/peerage-deep-dive.html"/>
    <id>https://stephenbussey.com/2018/02/07/peerage-deep-dive.html</id>
    <published>2018-02-06T21:10:00-05:00</published>
    <updated>2018-02-06T21:32:17-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I am going to continue off of &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;yesterdays&amp;rsquo; post&lt;/a&gt;
in order to look at how the &lt;a href="https://github.com/mrluc/peerage" target="_blank"&gt;Peerage&lt;/a&gt; library works. Peerage
is a pretty awesome library which makes Node discovery in distributed environments very easy.&lt;/p&gt;

&lt;h2&gt;Peerage Strategies&lt;/h2&gt;

&lt;p&gt;Peerage offers &lt;a href="https://github.com/mrluc/peerage#usage" target="_blank"&gt;several strategies&lt;/a&gt; which allow
for Node discovery. The most common one for me has been DNS, but the others can be just
as valuable depending on environment.&lt;/p&gt;

&lt;p&gt;At the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;simplest&lt;/a&gt;, a
Peerage discovery service must respond to the &lt;code&gt;poll()&lt;/code&gt; function. This is a pretty small
interface, which would make creating new discovery strategies very easy. The
&lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/self.ex" target="_blank"&gt;self&lt;/a&gt; strategy only
returns the current node in a List, which is essentially a no-op.&lt;/p&gt;

&lt;p&gt;We can look a little deeper at something that might do some actual connectivity,
the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/list.ex#L28" target="_blank"&gt;list&lt;/a&gt; strategy.
As we can see from this code, it&amp;rsquo;s really not complex. The application is setup with a list
of Node symbols, and those will try to connect through this strategy.&lt;/p&gt;

&lt;p&gt;Now we can finally get into some real work, with the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L45" target="_blank"&gt;UDP strategy&lt;/a&gt;.
UDP can be used to connect in a situation where nodes are on the same network, but are generally
unware of what other nodes are on the network. Digging into the UDP strategy, we can see that
UDP messages are sent over the network, and include the format &lt;code&gt;&amp;quot;Peer#{node()}&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Broadcast our node name via UDP every 3-7 seconds&amp;quot;
def handle_info(:broadcast, state = %{conn: {addr, port, sock}}) do
  :ok = :gen_udp.send(sock, addr, port, [&amp;quot;Peer:#{ node() }&amp;quot;])
  Process.send_after(self(), :broadcast, :rand.uniform(4_000) + 3_000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a UDP packet comes in, matching the format, that node is logged into state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@doc &amp;quot;Handle UDP packet. If it&amp;#39;s a node name broadcast, adds to `state.seen`.&amp;quot;
def handle_info({:udp,sock,_,_, &amp;quot;Peer:&amp;quot; &amp;lt;&amp;gt; name}, state = %{seen: ms}) do
  Logger.debug &amp;quot;  -&amp;gt; Peerage.Via.Udp sees: #{ name }&amp;quot;
  :inet.setopts(sock, active: 1)
  {:noreply, %{state | seen: ms |&amp;gt; MapSet.put(name |&amp;gt; String.to_atom)}}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/udp.ex#L52" target="_blank"&gt;this state is returned&lt;/a&gt; synchronously
when requested by the poller we saw previously.&lt;/p&gt;

&lt;p&gt;I really like this general approach because we can see that there isn&amp;rsquo;t real magic going on. Nodes
are broadcasting their name over the UDP connectionless protocol, and then letting the polling
service take over from there (which will be explained below).&lt;/p&gt;

&lt;p&gt;Finally, the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L32" target="_blank"&gt;DNS strategy&lt;/a&gt;, can
be used in multi-node situations where IPs are mapped to a DNS record. In kubernetes, for example,
the nodes can be mapped into a headless service and then resolved from there. The poll mechanism
of the DNS strategy is even simpler than UDP. Simply take the provided DNS name, look it up
using &lt;code&gt;:inet_res.lookup(&amp;#39;domain.com&amp;#39;, :in, :a)&lt;/code&gt;, and then &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/dns.ex#L38" target="_blank"&gt;turn the provided IPs into connectable
names&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Connection&lt;/h2&gt;

&lt;p&gt;My favorite part of peerage, by far, is how simple the &lt;a href="https://github.com/mrluc/peerage/blob/master/lib/peerage/server.ex" target="_blank"&gt;server&lt;/a&gt;
is that actually connects nodes together. The polling code triggers the &lt;code&gt;discover&lt;/code&gt; method
and reschedules for some interval in the future. If you haven&amp;rsquo;t seen it before, the
&lt;code&gt;Process.send_after&lt;/code&gt; line here is very common for creating gen servers which do some
regular interval&amp;rsquo;d work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def handle_info(:poll, state) do
  discover()
  Process.send_after(self(), :poll, interval() * 1000)
  {:noreply, state}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the real simplicity comes out with node connections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp discover do
  poll()
  |&amp;gt; only_fresh_node_names
  |&amp;gt; Enum.map(&amp;amp;([&amp;amp;1, Node.connect(&amp;amp;1)]))
  |&amp;gt; log_results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nodes are polled using the mechanisms we saw previously, then compared against currently
connected nodes. &lt;code&gt;Node.connect&lt;/code&gt; is then called on the symbol provided by the providers, and attempted
to connect to. When a Node connects, erlang handles all of the security and heartbeat, as
laid out in the &lt;a href="/2018/02/06/elixir-node-networking-basics.html" target="_blank"&gt;previous post&lt;/a&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;This simple and elegant library has been a cornerstone for me connecting nodes together in
kubernetes. It is great to see that there is no hacky implementations under the covers. It is
simply easy to follow and debug Elixir code, falling back on known erlang libraries.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 6th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Elixir Node Networking Basics</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html"/>
    <id>https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html</id>
    <published>2018-02-05T21:08:00-05:00</published>
    <updated>2018-02-06T00:17:22-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;One of my favorite points in Elixir, some form of magic perhaps, is how simple
distributed networking can be. The language itself seems to make establishing
networked nodes and sending messages a pain-free exercise. While breaking down
networking techniques is more than a single post, I am going to look into some of
the basics of networking in Elixir. Specifically, what happens when we connect
nodes together?&lt;/p&gt;

&lt;h2&gt;Nodes in Elixir&lt;/h2&gt;

&lt;p&gt;In Elixir, a &lt;code&gt;Node&lt;/code&gt; could be defined as a single running instance. There can be
multiple nodes running on a single machine. Let&amp;rsquo;s use this to take a look at some
basics of node communication, before diving into what is going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
iex --name test@127.0.0.1

# In shell 2
iex --name test2@127.0.0.1

# In shell 1
Node.self() # :&amp;quot;test@127.0.0.1&amp;quot;
Node.list() # []
Node.connect(:&amp;quot;test2@127.0.0.1&amp;quot;) # true
Node.list() # [:&amp;quot;test2@127.0.0.1&amp;quot;]

# In shell 2
Node.list() # [:&amp;quot;test@127.0.0.1&amp;quot;]

# Leave open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above interactive example, it&amp;rsquo;s possible to see that 2 nodes are initially
started, with a particular name of &lt;code&gt;test@127.0.0.1&lt;/code&gt; or test2. These nodes start as
disconnected, but can be manually connected. Once connected, both nodes are aware of the
other node&amp;rsquo;s existence.&lt;/p&gt;

&lt;p&gt;Finally, we can test out sending a message in the above processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
Node.spawn(:&amp;quot;test2@127.0.0.1&amp;quot;, fn -&amp;gt; IO.inspect(Node.self()) end)
#PID&amp;lt;13084.113.0&amp;gt;
:&amp;quot;test2@127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, a function is set to be executed on &lt;code&gt;:&amp;quot;test2@127.0.01&amp;quot;&lt;/code&gt;. We can see
that the result of the execution is a remote pid (doesn&amp;rsquo;t start with 0) as well the output
containing the node&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;The Node module contains lots of interesting tidbits that are actually implemented pretty
thin on top of erlang modules. This post won&amp;rsquo;t go into the ins and outs of node communication,
although it&amp;rsquo;s suffice to say that communication is generally done in better ways than
spawning functions between the nodes.&lt;/p&gt;

&lt;h2&gt;Diving into a connection&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/node.ex#L150" target="_blank"&gt;Node.connect&lt;/a&gt; provides
a really simple 1-liner over &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;. Let&amp;rsquo;s dig into this function and
what some ramifications of using it are.&lt;/p&gt;

&lt;p&gt;Deep inside of the erlang OTP libraries, we start to see some interesting code in connection.
Specifically, there is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L313" target="_blank"&gt;code&lt;/a&gt;
to handle automatic &amp;ldquo;magical&amp;rdquo; connection between nodes, vs more explicit connection dependencies.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L342" target="_blank"&gt;Digging even further&lt;/a&gt;,
we discover that the &lt;code&gt;net_kernel&lt;/code&gt; symbol is actually a process on the system. Running &lt;code&gt;Process.whereis(:net_kernel)&lt;/code&gt;
will return the pid of this net_kernel process.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L422" target="_blank"&gt;The first time that a Node is connected to&lt;/a&gt;,
that connection is not present in the ets lookup table. This leads to setup being called and
initializing that connection.&lt;/p&gt;

&lt;p&gt;By digging into &lt;code&gt;Process.whereis(:net_kernel) |&amp;gt; :sys.get_state()&lt;/code&gt;, it&amp;rsquo;s possible to see that
there is a structure like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:listen, #Port&amp;lt;0.609&amp;gt;, #PID&amp;lt;0.49.0&amp;gt;,
    {:net_address, {{0, 0, 0, 0}, 56479}, &amp;#39;Steves-MBP&amp;#39;, :tcp, :inet},
    :inet_tcp_dist}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This state is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L113" target="_blank"&gt;documented&lt;/a&gt;
and helps to let us trace the module that will actually connect our nodes together. Finally, we
are able to track down the &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/inet_tcp_dist.erl#L296" target="_blank"&gt;setup code&lt;/a&gt;
that is creating the TCP socket between the nodes.&lt;/p&gt;

&lt;p&gt;One small caveat of connecting to nodes is that &amp;ldquo;cookies&amp;rdquo; have to match up. This is
essentially an atom that is initialized on boot and read from &lt;code&gt;~/.erlang.cookie&lt;/code&gt;. Finding
this was pretty challenging in erlang, but I traced it back to
&lt;a href="https://github.com/erlang/otp/blob/d99803e7625e474dee40f0dfebf2b8092add0336/lib/kernel/src/dist_util.erl#L216" target="_blank"&gt;dist_util&lt;/a&gt;
module. The code above (even if you can&amp;rsquo;t read erlang) is doing some interesting challenge/reply
protocol to ensure that the nodes are allowed to talk to each other.&lt;/p&gt;

&lt;h2&gt;After the connection&lt;/h2&gt;

&lt;p&gt;Of course, connecting via TCP here is just the beginning. There is significantly more
at play, cookies to authenticate nodes and heartbeats to ensure connectivity between nodes
for starters. The &lt;a href="http://learnyousomeerlang.com/distribunomicon" target="_blank"&gt;distributed erlang guide&lt;/a&gt; from
learnyousomeerlang.com goes over some of these concepts in detail. I&amp;rsquo;ll be tackling them
in a future post as well.&lt;/p&gt;

&lt;h2&gt;Addendum&lt;/h2&gt;

&lt;p&gt;It was asked in the Elixir slack group if it&amp;rsquo;s possible to customize the distribution mechanism
from TCP/IP to something else. It is! It&amp;rsquo;s fairly involved C code, but there is &lt;a href="http://erlang.org/doc/apps/erts/alt_dist.html" target="_blank"&gt;an example&lt;/a&gt;
walking through a OS socket level distribution.&lt;/p&gt;

&lt;p&gt;In addition, some other drivers are provided out of the box, such as a
&lt;a href="http://erlang.org/doc/apps/ssl/ssl_distribution.html" target="_blank"&gt;SSL driver&lt;/a&gt; for communicating
over SSL.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;I don&amp;rsquo;t really read erlang code, so this post was very interesting today. However, a lot
of great things can be learned from digging into the erlang code and module documentation
and not relying solely on Elixir docs. For instance, the documentation for node networking
brings up great points around security and TLS node communication. Dive into the docs and
see what you go from there; it might be useful one day when there&amp;rsquo;s a problem that you
just can&amp;rsquo;t figure out.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 5th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
</feed>

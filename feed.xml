<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stephen Bussey's Software Engineering Blog</title>
  <id>https://stephenbussey.com</id>
  <link href="https://stephenbussey.com"/>
  <link href="https://stephenbussey.com/feed.xml" rel="self"/>
  <updated>2018-02-05T21:08:00-05:00</updated>
  <author>
    <name>Stephen Bussey</name>
  </author>
  <entry>
    <title>28 Days - Elixir Node Networking Basics</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html"/>
    <id>https://stephenbussey.com/2018/02/06/elixir-node-networking-basics.html</id>
    <published>2018-02-05T21:08:00-05:00</published>
    <updated>2018-02-06T00:17:22-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;One of my favorite points in Elixir, some form of magic perhaps, is how simple
distributed networking can be. The language itself seems to make establishing
networked nodes and sending messages a pain-free exercise. While breaking down
networking techniques is more than a single post, I am going to look into some of
the basics of networking in Elixir. Specifically, what happens when we connect
nodes together?&lt;/p&gt;

&lt;h2&gt;Nodes in Elixir&lt;/h2&gt;

&lt;p&gt;In Elixir, a &lt;code&gt;Node&lt;/code&gt; could be defined as a single running instance. There can be
multiple nodes running on a single machine. Let&amp;rsquo;s use this to take a look at some
basics of node communication, before diving into what is going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
iex --name test@127.0.0.1

# In shell 2
iex --name test2@127.0.0.1

# In shell 1
Node.self() # :&amp;quot;test@127.0.0.1&amp;quot;
Node.list() # []
Node.connect(:&amp;quot;test2@127.0.0.1&amp;quot;) # true
Node.list() # [:&amp;quot;test2@127.0.0.1&amp;quot;]

# In shell 2
Node.list() # [:&amp;quot;test@127.0.0.1&amp;quot;]

# Leave open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above interactive example, it&amp;rsquo;s possible to see that 2 nodes are initially
started, with a particular name of &lt;code&gt;test@127.0.0.1&lt;/code&gt; or test2. These nodes start as
disconnected, but can be manually connected. Once connected, both nodes are aware of the
other node&amp;rsquo;s existence.&lt;/p&gt;

&lt;p&gt;Finally, we can test out sending a message in the above processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# In shell 1
Node.spawn(:&amp;quot;test2@127.0.0.1&amp;quot;, fn -&amp;gt; IO.inspect(Node.self()) end)
#PID&amp;lt;13084.113.0&amp;gt;
:&amp;quot;test2@127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, a function is set to be executed on &lt;code&gt;:&amp;quot;test2@127.0.01&amp;quot;&lt;/code&gt;. We can see
that the result of the execution is a remote pid (doesn&amp;rsquo;t start with 0) as well the output
containing the node&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;The Node module contains lots of interesting tidbits that are actually implemented pretty
thin on top of erlang modules. This post won&amp;rsquo;t go into the ins and outs of node communication,
although it&amp;rsquo;s suffice to say that communication is generally done in better ways than
spawning functions between the nodes.&lt;/p&gt;

&lt;h2&gt;Diving into a connection&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/node.ex#L150" target="_blank"&gt;Node.connect&lt;/a&gt; provides
a really simple 1-liner over &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;. Let&amp;rsquo;s dig into this function and
what some ramifications of using it are.&lt;/p&gt;

&lt;p&gt;Deep inside of the erlang OTP libraries, we start to see some interesting code in connection.
Specifically, there is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L313" target="_blank"&gt;code&lt;/a&gt;
to handle automatic &amp;ldquo;magical&amp;rdquo; connection between nodes, vs more explicit connection dependencies.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L342" target="_blank"&gt;Digging even further&lt;/a&gt;,
we discover that the &lt;code&gt;net_kernel&lt;/code&gt; symbol is actually a process on the system. Running &lt;code&gt;Process.whereis(:net_kernel)&lt;/code&gt;
will return the pid of this net_kernel process.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L422" target="_blank"&gt;The first time that a Node is connected to&lt;/a&gt;,
that connection is not present in the ets lookup table. This leads to setup being called and
initializing that connection.&lt;/p&gt;

&lt;p&gt;By digging into &lt;code&gt;Process.whereis(:net_kernel) |&amp;gt; :sys.get_state()&lt;/code&gt;, it&amp;rsquo;s possible to see that
there is a structure like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:listen, #Port&amp;lt;0.609&amp;gt;, #PID&amp;lt;0.49.0&amp;gt;,
    {:net_address, {{0, 0, 0, 0}, 56479}, &amp;#39;Steves-MBP&amp;#39;, :tcp, :inet},
    :inet_tcp_dist}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This state is &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/net_kernel.erl#L113" target="_blank"&gt;documented&lt;/a&gt;
and helps to let us trace the module that will actually connect our nodes together. Finally, we
are able to track down the &lt;a href="https://github.com/erlang/otp/blob/1526eaead833b3bdcd3555a12e2af62c359e7868/lib/kernel/src/inet_tcp_dist.erl#L296" target="_blank"&gt;setup code&lt;/a&gt;
that is creating the TCP socket between the nodes.&lt;/p&gt;

&lt;p&gt;One small caveat of connecting to nodes is that &amp;ldquo;cookies&amp;rdquo; have to match up. This is
essentially an atom that is initialized on boot and read from &lt;code&gt;~/.erlang.cookie&lt;/code&gt;. Finding
this was pretty challenging in erlang, but I traced it back to
&lt;a href="https://github.com/erlang/otp/blob/d99803e7625e474dee40f0dfebf2b8092add0336/lib/kernel/src/dist_util.erl#L216" target="_blank"&gt;dist_util&lt;/a&gt;
module. The code above (even if you can&amp;rsquo;t read erlang) is doing some interesting challenge/reply
protocol to ensure that the nodes are allowed to talk to each other.&lt;/p&gt;

&lt;h2&gt;After the connection&lt;/h2&gt;

&lt;p&gt;Of course, connecting via TCP here is just the beginning. There is significantly more
at play, cookies to authenticate nodes and heartbeats to ensure connectivity between nodes
for starters. The &lt;a href="http://learnyousomeerlang.com/distribunomicon" target="_blank"&gt;distributed erlang guide&lt;/a&gt; from
learnyousomeerlang.com goes over some of these concepts in detail. I&amp;rsquo;ll be tackling them
in a future post as well.&lt;/p&gt;

&lt;h2&gt;Addendum&lt;/h2&gt;

&lt;p&gt;It was asked in the Elixir slack group if it&amp;rsquo;s possible to customize the distribution mechanism
from TCP/IP to something else. It is! It&amp;rsquo;s fairly involved C code, but there is &lt;a href="http://erlang.org/doc/apps/erts/alt_dist.html" target="_blank"&gt;an example&lt;/a&gt;
walking through a OS socket level distribution.&lt;/p&gt;

&lt;p&gt;In addition, some other drivers are provided out of the box, such as a
&lt;a href="http://erlang.org/doc/apps/ssl/ssl_distribution.html" target="_blank"&gt;SSL driver&lt;/a&gt; for communicating
over SSL.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;I don&amp;rsquo;t really read erlang code, so this post was very interesting today. However, a lot
of great things can be learned from digging into the erlang code and module documentation
and not relying solely on Elixir docs. For instance, the documentation for node networking
brings up great points around security and TLS node communication. Dive into the docs and
see what you go from there; it might be useful one day when there&amp;rsquo;s a problem that you
just can&amp;rsquo;t figure out.&lt;/p&gt;

&lt;p&gt;Thanks for reading the 5th post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate a few more posts around networking, such as cookie gotchas, distillery release networking,
and pg2.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Sourcing Libraries from Private Github</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html"/>
    <id>https://stephenbussey.com/2018/02/05/sourcing-libraries-from-private-github.html</id>
    <published>2018-02-04T19:57:00-05:00</published>
    <updated>2018-02-04T20:29:42-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Hex is currently working on &lt;a href="https://hex.pm/docs/private" target="_blank"&gt;private organizations&lt;/a&gt; which
are in beta. Until the full details of those are public and available, you may find
yourself needing to source Elixir libraries privately. You may also just desire a quick
fix and not setting up private packages. Enter git sourced packages.&lt;/p&gt;

&lt;h2&gt;Mix and Git&lt;/h2&gt;

&lt;p&gt;At the simplest form, you can think of git sourced dependencies as a clone of the provided
repo using system git. In fact, the implementation is
a &lt;a href="https://github.com/elixir-lang/elixir/blob/f77cc2657cf981fdf819915f1ee15e69c3cd91ad/lib/mix/lib/mix/scm/git.ex#L250" target="_blank"&gt;shell out to git&lt;/a&gt;.
This means any repo which a system can access will be accessible via git, including
repos which are locked behind private access.&lt;/p&gt;

&lt;p&gt;I have seen tags work as a good way to mark the versions in the git repo. The form looks
something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: &amp;quot;v1.0.0&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above mix.exs entry will fetch the mix package named &lt;code&gt;:my_dependency_name&lt;/code&gt; from git@github.com:Organization/repo.git,
commit tagged v1.0.0. &lt;a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank"&gt;Github SSH&lt;/a&gt; access
is used due to the repo being &lt;code&gt;git@github.com&lt;/code&gt; format.&lt;/p&gt;

&lt;h2&gt;Trickery with Docker and CI&lt;/h2&gt;

&lt;p&gt;This all works well locally. In fact, just following the standard tutorial will lead to a working
private dependency, locally. Things get a bit trickier when something like Docker or a build
server is used to fetch your dependency. In this situation, the SSH key of each system would need
to be included on Github. Another difficulty is that Docker containers have to have SSH keys added
to them, they don&amp;rsquo;t come with them standard. All of this leads to another possible solution:
accessing Github via API keys.&lt;/p&gt;

&lt;h2&gt;API Key Setup&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/blog/1509-personal-api-tokens" target="_blank"&gt;Github personal access tokens&lt;/a&gt; can be used
to access certain parts of Github, such as repository access. In order to use one with mix,
just switch out the git url from &lt;code&gt;git@github.com:Organization/repo.git&lt;/code&gt; to
&lt;code&gt;https://#{access_token}@github.com/Organization/repo&lt;/code&gt;. With this solution, any access token
which has read access to the repo will serve as the access into Git.&lt;/p&gt;

&lt;p&gt;There does exist a drawback with this solution, the access token would need to be provided to
every user of the application. This is non-desirable as the access token should really be kept
secret, even to the point of being encrypted docker arguments. With a small tweak, it is possible to
achieve the best of both worlds, SSH locally but access tokens for Docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp deps do
  [
    {:phoenix, &amp;quot;~&amp;gt; 1.3.0&amp;quot;},
  ] ++ private_deps(System.get_env(&amp;quot;MIX_GITHUB_ACCESS_TOKEN&amp;quot;))
end

@my_dependency_version &amp;quot;v1.0.0&amp;quot;

defp private_deps(nil) do
  [
    {:my_dependency_name, git: &amp;quot;git@github.com:Organization/repo.git&amp;quot;, tag: @my_dependency_version},
  ]
end

defp private_deps(access_token) do
  [
    {:my_dependency_name, git: &amp;quot;https://#{access_token}@github.com/Organization/repo&amp;quot;, tag: @my_dependency_version},
  ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script will append the private dependencies into the deps list, but do so with
either SSH or access token access. Dependency versions should always be constant, so
it is pulled into an attribute.&lt;/p&gt;

&lt;p&gt;One caveat with this approach is that each mix invocation must contain the ENV, not
just &lt;code&gt;deps.get&lt;/code&gt;. This is due to the mix.lock being checked when mix runs, and the
correct dependencies are pulled each time through the above code path.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;With the presented approach, there should be little trouble getting private repos
both locally and in CI, without compromise on security of your keys. If the straight access
token route is taken, take extra care regarding the permissions of the account behind
the key.&lt;/p&gt;

&lt;p&gt;Thanks for reading the fourth post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;. I
anticipate the posts to get more and more technical as the time goes on!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 Days - Bringing Elixir to Others - New Language vs. New Paradigm</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html"/>
    <id>https://stephenbussey.com/2018/02/03/bringing-elixir-to-others-new-language-vs-new-paradigm.html</id>
    <published>2018-02-03T14:46:00-05:00</published>
    <updated>2018-02-03T15:10:05-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;rsquo;ll be giving a talk next week about taking Elixir into production. While there are
technical challenges to doing so, I must also consider the human-based challenges that will be faced. For
example, most team members will be learning a new language when they are introduced to Elixir.
If they have been doing object-oriented coding, will a functional coding paradigm get them stuck?
Will OTP and the paradigm of a process based application cause confusion?&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t necessarily present answers to some of these questions today, but rather bring up
questions that I&amp;rsquo;ve heard and alternative ways of thinking about the answers.&lt;/p&gt;

&lt;h2&gt;Functional Programming and Elixir Itself&lt;/h2&gt;

&lt;p&gt;Before all of the fun and excitement of making a real Elixir application comes the challenge of
learning the Elixir language. Most people that ask me about learning Elixir focus on what
types of courses they can pay for online to get into the language. While I&amp;rsquo;m sure that some
people are going to benefit from these courses enormously, it&amp;rsquo;s never the first place I&amp;rsquo;d send
someone. Instead, I recommend the &lt;a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank"&gt;Elixir Getting Started Guide&lt;/a&gt;.
This guide is put together by the official Elixir team and covers an introduction to the language itself.&lt;/p&gt;

&lt;p&gt;As other members of the organization dive into the concepts of Elixir, questions will
be raised about what functional programming is, what does immutability mean, and what is &amp;ldquo;all of this&amp;rdquo; in practice?
Even further questioning might ask &amp;ldquo;what makes the functional paradigm good?&amp;rdquo; Other team members will rely
on the Elixir champion to answer these questions, so be prepared for them to pop up once people start learning.
I read something in a reddit comment today that I really liked on this topic: the value of the data
doesn&amp;rsquo;t change in Elixir, but rather the variables point to new pieces of data. I thought that was a
very straight-forward way of looking at the functional programming model that Elixir brings.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I prep anyone that is going through the getting started guide that it will take probably 2-4 times
to really understand Elixir to the point of being comfortable when reading other people&amp;rsquo;s code. Having
a real world project to read and play around with can lower this learning curve.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;OTP&lt;/h2&gt;

&lt;p&gt;OTP is a cornerstone of writing Elixir applications. There&amp;rsquo;s lot of things about the topic already, but
I had an interesting observation the other day about OTP and how it relates to bringing Elixir to the
rest of an organization:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The majority of business applications could be built with all OTP hidden away by libraries, to the point
of developers not needing to know the details of OTP.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While I think that using OTP can help bring about advantages in an application, especially in a distributed
environment, it is not really necessary. For example, a developer could start a new application today and
serve the HTTP layer with Phoenix. They could then spin up a queue system like ExQ in order to process
background jobs. Finally, they can connect websockets for read/write access to the API. All of this can happen
without ever typing &lt;code&gt;GenServer&lt;/code&gt; in code and create an application which satisfies the business.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t necessarily best practice, but I believe that it&amp;rsquo;s okay to sometimes put aside best practice
in order to achieve an initial velocity. Once the team is rolling, the OTP concepts will come out of the
woodwork and start to make sense, hopefully faster than they would in isolation.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Regardless of how you approach bringing Elixir to the people on your team, realize that you must be a
champion for the education and empowerment of the team. Look for interesting ways to answer questions that
people have and remove the roadblocks that pop-up as quick as you can.&lt;/p&gt;

&lt;p&gt;Thanks for reading the third post in my 28 days of Elixir. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Silly Mistakes I Make Again and Again</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html"/>
    <id>https://stephenbussey.com/2018/02/02/28-days-of-elixir-silly-mistakes-i-make-again-and-again.html</id>
    <published>2018-02-02T01:30:00-05:00</published>
    <updated>2018-02-02T02:10:29-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;It&amp;rsquo;s day 2 of my 28 days of Elixir blogging. I have 5 more ideas in the funnel, and I fear
that coming up with 28 interesting topics will be hard. I&amp;rsquo;ll definitely be leaning on
co-workers for ideas, but don&amp;rsquo;t hesitate to reach out if you have any interesting ideas
that you&amp;rsquo;d want me to explore!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been writing Elixir daily at SalesLoft, and have gotten pretty quick with development
and testing of my apps. However, a few things just keep catching me up every time:&lt;/p&gt;

&lt;h2&gt;Charlist and Strings&lt;/h2&gt;

&lt;p&gt;In both Ruby and Javascript, it is acceptable to swap &amp;lsquo; and &amp;ldquo;  for strings, in many cases.
This means that &amp;#39;a&amp;rsquo; === &amp;quot;a&amp;rdquo; in Javascript. However, &amp;lsquo;a&amp;rsquo; != &amp;ldquo;a&amp;rdquo; in Elixir. This is due to
charlist and string being implemented differently. Charlist is often used for interfacing
with erlang directly, because erlang does not have the concept of &amp;ldquo;strings&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;One mistake I will often catch is swapping the usage of the quote constructs and then
doing equality or other comparisons, and being bewildered when the strings do not match.
Catching this error can be a bit tricky if the error message doesn&amp;rsquo;t show you that the
types are different, but a usual symptom is being completely bewildered why two matching
strings are not matching. The most significant place to pay attention to is when interfacing
with code between libraries, as the target and source are separated.&lt;/p&gt;

&lt;h2&gt;Running mix test on the source file&lt;/h2&gt;

&lt;p&gt;This one is always a face-palmer. When running &lt;code&gt;mix test test/my_test.exs&lt;/code&gt;, be careful of
accidentally copying a path like &lt;code&gt;mix test lib/my.ex&lt;/code&gt;. The symptom of this mistake is a
passing spec suite which runs 0 specs, and complains about a re-defined module.&lt;/p&gt;

&lt;h2&gt;Define a test file with the same name as the real module, rather than test&lt;/h2&gt;

&lt;p&gt;My flow for creating a module is to create the source module (.ex), then running
(opt-g-t) to create a test script (.exs). I will then copy the source module definition
and add ExUnit and &lt;code&gt;Test&lt;/code&gt; to the end of the module.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;m going red/green on my code, I sometimes find myself shocked that a function
doesn&amp;rsquo;t exist when I most certainly just defined it. After looking around wondering
what is going on, I realize I forgot to include &lt;code&gt;Test&lt;/code&gt; at the end of the module. This
re-initializes the module (without real code) but is still a sementically valid
test file.&lt;/p&gt;

&lt;h2&gt;Not recognizing pattern matching in test helpers such as assert received&lt;/h2&gt;

&lt;p&gt;This is one of the more interesting / subtle mistakes that I find myself making. I especially
see this in older Elixir code that I wrote where I didn&amp;rsquo;t fully understand what was
going on.&lt;/p&gt;

&lt;p&gt;I will be doing a task like writing / testing a websocket channel and find that my
code passes perfectly when I know that it&amp;rsquo;s definitely not working correctly. I will
be trying to make my code go red but simply can&amp;rsquo;t make it. Usually, it turns out
that I&amp;rsquo;m using a function like &lt;a href="https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html#assert_push/3" target="_blank"&gt;assert_push/3&lt;/a&gt;
that is actually a macro. The way these are written, the function is actually
doing pattern matching rather than exact checks. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is different than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expected_payload = %{foo: &amp;quot;bar&amp;quot;}
assert_push &amp;quot;some_event&amp;quot;, ^expected_payload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is highlighted in the assert_push documentation, but essentially the first example
doesn&amp;rsquo;t check that the payload is &lt;em&gt;exactly&lt;/em&gt; the expected payload. This means that there could
be something like a data leak and our test wouldn&amp;rsquo;t catch it! Pattern matching the responses
can be super useful, but make sure that it&amp;rsquo;s happening when you expect it, and not
when you don&amp;rsquo;t!&lt;/p&gt;

&lt;p&gt;Thanks for reading, today. Keep up through the month of February to see if I can
stand subjecting myself to &lt;a href="/tags/28-days-of-elixir.html" target="_blank"&gt;28 days of straight writing&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>28 days of Elixir - Development Environment</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html"/>
    <id>https://stephenbussey.com/2018/02/01/28-days-of-elixir-development-environment.html</id>
    <published>2018-02-01T01:30:00-05:00</published>
    <updated>2018-02-02T01:41:19-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Welcome to day 1 of (hopefully) 28 days of Elixir! I&amp;rsquo;ve set a goal to write a technical blog
post every single day this month, and I&amp;rsquo;m really excited about Elixir right now. I don&amp;rsquo;t know
what the entire series will bring, but I do know that I&amp;rsquo;ll basically have to be putting all of my
thoughts and experiences about Elixir out there over the next month.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to start this series off with something light: development environments. Specifically,
the one that I use and things that I&amp;rsquo;ve found enjoyable coming from another language like Ruby
or Javascript. I don&amp;rsquo;t intend to convince anyone of anything on this (especially with regards
to editors), but I do think there&amp;rsquo;s some interesting things about Elixir specifically that
can apply to every environment. Let&amp;rsquo;s jump in.&lt;/p&gt;

&lt;h2&gt;Elixir Installation&lt;/h2&gt;

&lt;p&gt;I use &lt;a href="https://github.com/taylor/kiex" target="_blank"&gt;kiex&lt;/a&gt; to manage my elixir versions
and &lt;a href="https://github.com/kerl/kerl" target="_blank"&gt;kerl&lt;/a&gt; to manage my erlang/OTP versions. kiex has
been great, it&amp;rsquo;s really easy to use! I have to say that I&amp;rsquo;m genuinely impressed with
how little speed bumps I&amp;rsquo;ve encountered over time. I do recommend using some sort of
version manager rather than brew, because there will definitely be more than one project
in Elixir over time!&lt;/p&gt;

&lt;p&gt;kerl on the other hand, has generally been fairly painful to use. I think the biggest
thing here is that Elixir versions need recompiled once OTP is changed. I could be
wrong here because I haven&amp;rsquo;t had to do it too often, but I do distinctly remember
significant pain from the OTP 20 upgrade. This happens very infrequently though.&lt;/p&gt;

&lt;p&gt;One thing that I wish kiex had was the concept of a .elixir-version file like rbenv. It
has to be done manually right now, which is error prone on a team.&lt;/p&gt;

&lt;h2&gt;My Editor&lt;/h2&gt;

&lt;p&gt;Although I&amp;rsquo;ve tried to get into other editors over time, I have found myself drawn again
and again to the simplicity and flexibility of atom, so that&amp;rsquo;s what I&amp;rsquo;ve been using lately.
There are 3 packages that I use specifically for atom that are, I think, absolute
must haves: atom-elixir, language-elixir, elixir-jump-around.&lt;/p&gt;

&lt;p&gt;atom-elixir and language-elixir provide the base for the actual act of authoring code.
The auto-complete functionality works generally well, although there are some core quirks.
Due to how Elixir compilation works, tools like atom-elixir look into the actual _build
output of the code to produce auto-complete and documentation services. This is really interesting
to me, because it means that &lt;em&gt;any&lt;/em&gt; editor should be able to accomplish that same task. Whether
emacs, vim, vscode, whatever is being used, it should be completely achievable to have full
auto-complete and documentation capabilities.&lt;/p&gt;

&lt;p&gt;In addition to great auto-complete capabilities, atom-elixir has a really good &amp;ldquo;go to definition&amp;rdquo;
functionality. When I am authoring Ruby code, I find that only Rubymine has been able to
achieve true definition jumping. ctags can provide some of it, but jumping into installed
libraries is very useful for debugging problems or understanding how a method works. For example,
do you want to know how an Enum method is implemented? Just alt+click and you&amp;rsquo;re there! Elixir&amp;rsquo;s
compilation design makes this all possible in any editor, not just a Jetbrains editor. Check
it out!&lt;/p&gt;

&lt;p&gt;Lastly, &amp;ldquo;jump to test&amp;rdquo; is so useful for me. My typical flow for creating a file has become:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create the module in my lib folder somewhere&lt;/li&gt;
&lt;li&gt;Press opt-g-t to jump to the non-existent file&lt;/li&gt;
&lt;li&gt;Copy the module definition, add Test to it, then save the file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m able to do this entire flow very quickly and without navigating a file tree.&lt;/p&gt;

&lt;h2&gt;Docker vs Native Execution&lt;/h2&gt;

&lt;p&gt;Some people really like to develop software on the OS that is going to run it in production,
and more power to them! However, I&amp;rsquo;ve found myself drawn to having software that is runnable
on my macbook, natively, rather than using a tool like Docker or Vagrant. However, I do utilize
Docker for CI and production build processes.&lt;/p&gt;

&lt;h2&gt;Mix Format&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve begrudgingly accepted the mix formatter over the past few weeks. I find that I often
have issues with getting a file to format in certain situations. This seems like a bug in the formatter,
though. The format itself is generally agreeable but sometimes is not and there is no
customization route. I think that it&amp;rsquo;s better to accept a standard, even if it&amp;rsquo;s not
my desired standard, if it improves the community and team at large.&lt;/p&gt;

&lt;p&gt;I run this manually as I go. Now that I think about it more, I should probably have this setup
in some semi-automated fashion until it becomes too slow.&lt;/p&gt;

&lt;h2&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;That ended up being longer than I anticipated, but I&amp;rsquo;m still sure there are many things
I didn&amp;rsquo;t cover. Feel free to reach out if you have any question about how my setup
works or if you have awesome tools that you can&amp;rsquo;t live without!&lt;/p&gt;

&lt;p&gt;See ya tomorrow hopefully! It is only day 1, so we&amp;rsquo;ll have to see how it goes.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Designing Elixir Supervisor Trees</title>
    <link rel="alternate" href="https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html"/>
    <id>https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html</id>
    <published>2018-01-07T21:47:00-05:00</published>
    <updated>2018-02-01T01:56:07-05:00</updated>
    <author>
      <name>Stephen Bussey</name>
    </author>
    <content type="html">&lt;p&gt;Over the past year, I&amp;rsquo;ve been getting more and more into Elixir. The language and
paradigm has shifted how I think about coding in Ruby and has been incredibly &lt;em&gt;fun&lt;/em&gt;
to work with. One of the core concepts of an Elixir application is the supervision tree.
Let&amp;rsquo;s dive into some patterns that I typically use, along with some real code.&lt;/p&gt;

&lt;h2&gt;Supervisors and Processes&lt;/h2&gt;

&lt;p&gt;A process in Elixir is an isolated unit of execution. Processes have their own stack,
&amp;ldquo;run queue&amp;rdquo;, and garbage collection. Because of this level of isolation, it helps to think
of them as small programs that can talk to other small programs in an application. Processes
are crucial for storing and accessing dynamic data, as well as for implementing transformations
around data. A process executes all operations in its run queue sequentially, but multiple
run queues can execute concurrently (leading to true concurrency). If you are curious about this
specifically, I find
Hamidreza Soleimani&amp;rsquo;s &lt;a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html" target="_blank"&gt;blog post&lt;/a&gt;
fascinating.&lt;/p&gt;

&lt;p&gt;A supervisor is a process that manages the lifecycles of child processes. This most often
comes through as a fault tolerance mechanism. If a process crashes, the parent supervisor
can choose to restart it, let it stay dead, restart it and all peers, etc. A supervisor
can supervise other supervisors, which leads to a supervision tree.&lt;/p&gt;

&lt;h2&gt;Modeling a Problem&lt;/h2&gt;

&lt;p&gt;The problem that I&amp;rsquo;m going to discuss today is the model of a game server for the game
generals.io. This is a turn-based &amp;ldquo;real-time&amp;rdquo; strategy game that involves capturing towns
with armies and overtaking the enemy generals. Users can queue up moves to execute sequentially
over turns. This allows complex moves to be planned out and executed without losing time.&lt;/p&gt;

&lt;p&gt;In this problem, there are a few concepts that stick out to me:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Board: A board is the representation of what the current state of the game is. This would
include the cell types, the state of the armies, the fog of war, etc&lt;/li&gt;
&lt;li&gt;Command queue: This stores the entire set of commands for the game. It is write-ahead and
knows what commands have been executed and which are in the future (and on which turn)&lt;/li&gt;
&lt;li&gt;Player list: Not as obvious as the others, but we need to know what players are in a game,
and what the mapping is to their login&lt;/li&gt;
&lt;li&gt;Game: The game contains all of the above things and ticks every so often, progressing the
gameplay along&lt;/li&gt;
&lt;li&gt;Game list: Building an online game requires supporting multiple games at once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m going to walk through each of these concepts (in order) and explain the approach I
took in implementing the supervision tree. First, let&amp;rsquo;s see what that supervision tree
might look like.&lt;/p&gt;

&lt;h2&gt;Supervision Tree for Our Game&lt;/h2&gt;

&lt;p&gt;What I&amp;rsquo;m about to present doesn&amp;rsquo;t come immediately (well, maybe with more practice),
and is something that came about through iterations and testing the waters with different
code. This is the final product, which I&amp;rsquo;ll go into more detail on. The [] syntax indicates
what the children are.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Application -&amp;gt; [GamesSupervisor, GameRegistry, WebEndpoint]
GamesSupervisor (1 child type) -&amp;gt; [GameSupervisor (dynamic)]
GameSupervisor (4 child type) -&amp;gt; [BoardServer, CommandQueueServer, TickServer, PlayerServer]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;BoardServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/board_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;When building the game, I started with the board object and naturally progressed into
the BoardServer. I feel that starting on the inner nodes of the supervisor can make
it more obvious what the next steps are, rather than trying to plan out everything
at once.&lt;/p&gt;

&lt;p&gt;Notes on the code:&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve found myself trying to keep servers as simple as possible,
and executing complex logic in plain old modules which don&amp;rsquo;t have any GenServer
capability. When looking at the BoardServer, I&amp;rsquo;m happy to see that there is no
real logic in it, other than turn + 1.&lt;/p&gt;

&lt;p&gt;Defining a simple interface is crucial for communication between GenServers. I&amp;rsquo;ve
found myself getting stuck in between more verbose interfaces in the past and always
regret whatever brought me there.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice that I don&amp;rsquo;t use any of the GenServer helpers to remove boiler plate.
I&amp;rsquo;ve found that keeping it to pure Elixir makes it easier to read in the long run,
and increases my consistency across projects.&lt;/p&gt;

&lt;h2&gt;CommandQueueServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/command_queue_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Following the theme of keeping GenServers simple, this one is even more simple.
When I&amp;rsquo;m dealing with a GenServer that really only touches one thing, like this one
dealing with a Queue implementation, I do like to reach for Agent. Using an Agent
removes the need to build a real GenServer implementation, and increases the
readability significantly.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t find myself reaching for an Agent often, and will pull it out to a regular
GenServer if it gets too complex.&lt;/p&gt;

&lt;h2&gt;PlayerServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/player_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This is another simple Agent implementation that I feel like got a little bit sloppy.
This is due to the use of a Map rather than a custom data structure. To clean up
this code, I would look at extracting the Map behavior into a specific PlayerList
module.&lt;/p&gt;

&lt;h2&gt;TickServer &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/tick_server.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I love this TickServer. One of my favorite lines of code in Elixir has been:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Process.send_after(self(), :start_tick, timeout)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is going to send a message from one process to itself, but set for the future.
This allows creation of non-blocking (while the waiting is happening) GenServer implementations
that are implemented entirely using native Elixir concepts.&lt;/p&gt;

&lt;p&gt;Another interesting point here is that the TickServer accepts a &lt;code&gt;ticker_fn&lt;/code&gt; in the server
initialization. We&amp;rsquo;ll see this pop up in our GameServer later. I thought this technique was
really interesting (and was sort of surprised it worked). It works due to the fact that
a fn in Elixir can be passed around like any other variable, and Elixir is stateless which
means that the fn doesn&amp;rsquo;t get any context from where it is defined. Be warned, however, that
executing a fn in the TickServer is going to block the TickServer until that function
completes; it is not going to execute in the server that defined the fn.&lt;/p&gt;

&lt;h2&gt;GameSupervisor &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/game_supervisor.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s a lot going on in this supervisor, so let&amp;rsquo;s take it slow and just look at a few
specific concepts.&lt;/p&gt;

&lt;p&gt;The first thing to point out is the use of Registry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def start_link(opts = %{game_id: id}) do
  Supervisor.start_link(__MODULE__, opts, name: {:via, Registry, {get_registry_name(), id}})
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the Registry allows for a named dynamic lookup / uniqueness of a GenServer. The
supervisor is defined by the id passed in, which would prevent two games from ever sharing
the same id at the same time. As you can imagine, that would be bad. We can take advantage
of the uniqueness as well, because another GenServer that is started with this id will return
the pid in the start_link call. We&amp;rsquo;ll see this through in the GamesSupervisor below.&lt;/p&gt;

&lt;p&gt;Another useful code snippet is for looking up a process by type under a supervisor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defp find_child_type(sup_pid, type) do
  Enum.find(Supervisor.which_children(sup_pid), {nil, nil, nil, nil}, fn({mod, _pid, _type, _}) -&amp;gt;
    mod == type
  end) |&amp;gt; elem(1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve begun putting this in a Utils namespace in my new projects, but the gist is simple.
By using the supervisor&amp;rsquo;s pid, we can list out all of its children and find the one
with a given type (or base it on other things). GameSupervisor only has 1 child of
each type, which makes this work well.&lt;/p&gt;

&lt;p&gt;Our trust &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/game_supervisor.ex#L76" target="_blank"&gt;ticker_fn&lt;/a&gt; is
defined in this GameSupervisor. The reason I took this approach is that the knowledge of how to tick
should belong to something separate from what the ticking behavior is. Looking at this now,
I would probably pull this code into another module since it&amp;rsquo;s so long.&lt;/p&gt;

&lt;h2&gt;GamesSupervisor &lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/game/games_supervisor.ex" target="_blank"&gt;[code]&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve finally made it to the top of the supervision tree with the GamesSupervisor. This
supervisor takes advantage of the GameRegistry to provide game lookups:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def get_game(id, opts \\ []) do
  options = Keyword.merge([name: __MODULE__], opts)
  Supervisor.start_child(options[:name], [%{game_id: id}]) |&amp;gt; case do
    {:error, {:already_started, pid}} -&amp;gt; pid
    {:error, _} -&amp;gt; nil
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the GameSupervisor is identified by the id, which will return when
&lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; is returned from the start_child call. I use
this pattern in nearly every dynamic supervisor that I&amp;rsquo;ve written. I do typically
implement start/get in the same method (starting if it doesn&amp;rsquo;t exist, getting if it does),
but I found that to not work well as creating a new game involves several complex
operations such as board generation.&lt;/p&gt;

&lt;h2&gt;Registry&lt;/h2&gt;

&lt;p&gt;If you use a Registry, you do need to start it as a process in your application. I
generally just include it at the top level of my
&lt;a href="https://github.com/sb8244/generals/blob/aaea0e672f5dc0ebe616f4558a2c5912dd590da0/lib/generals/application.ex#L9" target="_blank"&gt;Application module&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;One good sign that your supervision tree has come together well is a very simple
mounting of it onto your final Application. Writing &lt;code&gt;supervisor(Generals.GamesSupervisor, [])&lt;/code&gt;
seems like a very clean interface for interacting with my game supervision tree, and
I feel good about that.&lt;/p&gt;

&lt;p&gt;Another key thing to think of when writing your supervision tree is what can / will
execute concurrently. For instance, let&amp;rsquo;s say that your PlayerList is implemented in
the same GenServer as the Board. If you want to access the PlayerList to see who is
in a game, it would not be able to run concurrently with Board operations. By splitting
them up into separate GenServer implementations, they can execute concurrently (keep in
mind that Elixir automatically distributes across cores).&lt;/p&gt;

&lt;p&gt;I hope this helped or solidified GenServer concepts for you. Please feel free to reach out
with any cool tips or tricks.&lt;/p&gt;
</content>
  </entry>
</feed>
